<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Static Analysis Report - FreeRTOS C++ Wrappers</title>
    <style>
        /* Apple Developer-inspired report styling */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=SF+Mono:wght@400;500;600&display=swap');
        
        :root {
            --apple-blue: #0A84FF;
            --apple-blue-dark: #0071E3;
            --apple-gray: #8E8E93;
            --apple-gray-light: #2C2C2E;
            --background: #1C1C1E;
            --surface: #2C2C2E;
            --surface-elevated: #3A3A3C;
            --text-primary: #FFFFFF;
            --text-secondary: #EBEBF5CC;
            --text-tertiary: #EBEBF599;
            --border: #48484A;
            --separator: #38383A;
            --success: #30D158;
            --warning: #FF9F0A;
            --error: #FF453A;
            --shadow-sm: 0 1px 3px 0 rgba(0, 0, 0, 0.3), 0 1px 2px 0 rgba(0, 0, 0, 0.2);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --radius: 8px;
            --radius-lg: 12px;
            --space-sm: 0.5rem;
            --space-md: 0.75rem;
            --space-lg: 1rem;
            --space-xl: 1.5rem;
            --space-2xl: 2rem;
            --space-3xl: 3rem;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Inter', 'SF Pro Display', sans-serif;
            font-size: 17px;
            line-height: 1.47059;
            color: var(--text-primary);
            background: var(--background);
            margin: 0;
            padding: 0;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        .header {
            background: linear-gradient(135deg, var(--apple-blue) 0%, var(--apple-blue-dark) 100%);
            color: white;
            padding: var(--space-2xl);
            box-shadow: var(--shadow-md);
        }
        
        .header h1 {
            font-size: 32px;
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.015em;
        }
        
        .header p {
            font-size: 19px;
            margin-top: var(--space-sm);
            opacity: 0.92;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-3xl) var(--space-2xl);
        }
        
        .summary-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: var(--space-xl);
            margin: var(--space-2xl) 0;
        }
        
        .card {
            background: var(--surface-elevated);
            border: 1px solid var(--separator);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            box-shadow: var(--shadow-sm);
            position: relative;
            overflow: hidden;
        }
        
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--apple-blue), var(--success));
            border-radius: var(--radius-lg) var(--radius-lg) 0 0;
        }
        
        .card h3 {
            font-size: 21px;
            font-weight: 600;
            color: var(--text-primary);
            margin: 0 0 var(--space-md) 0;
        }
        
        .metric {
            font-size: 32px;
            font-weight: 700;
            color: var(--apple-blue);
            margin: var(--space-sm) 0;
        }
        
        .metric.success { color: var(--success); }
        .metric.warning { color: var(--warning); }
        .metric.error { color: var(--error); }
        
        .section {
            background: var(--surface-elevated);
            border: 1px solid var(--separator);
            border-radius: var(--radius-lg);
            padding: var(--space-2xl);
            margin: var(--space-2xl) 0;
            box-shadow: var(--shadow-sm);
        }
        
        .section h2 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-primary);
            margin: 0 0 var(--space-xl) 0;
            border-bottom: 2px solid var(--separator);
            padding-bottom: var(--space-md);
        }
        
        .code-block {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: var(--space-xl);
            margin: var(--space-lg) 0;
            overflow-x: auto;
            font-family: 'SF Mono', 'Menlo', monospace;
            font-size: 14px;
            line-height: 1.45;
        }
        
        .timestamp {
            color: var(--text-tertiary);
            font-size: 15px;
            text-align: center;
            margin-top: var(--space-2xl);
            padding-top: var(--space-xl);
            border-top: 1px solid var(--separator);
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: var(--space-lg) 0;
            background: var(--surface-elevated);
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow-sm);
        }
        
        table th {
            background: var(--surface);
            color: var(--text-primary);
            font-weight: 600;
            padding: var(--space-lg);
            text-align: left;
            border-bottom: 2px solid var(--separator);
        }
        
        table td {
            padding: var(--space-lg);
            border-bottom: 1px solid var(--separator);
            color: var(--text-secondary);
        }
        
        table tr:hover {
            background: var(--surface);
        }
        
        .badge {
            display: inline-block;
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius);
            font-size: 14px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .badge.success {
            background: rgba(52, 199, 89, 0.1);
            color: var(--success);
        }
        
        .badge.warning {
            background: rgba(255, 149, 0, 0.1);
            color: var(--warning);
        }
        
        .badge.error {
            background: rgba(255, 59, 48, 0.1);
            color: var(--error);
        }
        
        @media (max-width: 768px) {
            .container {
                padding: var(--space-xl);
            }
            
            .header h1 {
                font-size: 28px;
            }
            
            .summary-cards {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Static Analysis Report</h1>
        <p>Automated code quality analysis using clang-tidy</p>
    </div>
    
    <div class="container">
        <div class="summary-cards">
                <div class="card">
                    <h3>Issues</h3>
                    <div class="metric">0</div>
                </div>
                
                <div class="card">
                    <h3>Warnings</h3>
                    <div class="metric warning">0</div>
                </div>
                
                <div class="card">
                    <h3>Errors</h3>
                    <div class="metric error">0</div>
                </div>
                
                <div class="card">
                    <h3>Files</h3>
                    <div class="metric">9</div>
                </div>
                </div><h1 id="static-analysis-report">Static Analysis Report</h1>
<div class="section"><h2 id="overview">Overview</h2>
<p><strong>Static Analysis Tools</strong>: clang-tidy + Enhanced cppcheck (all rules) + MISRA C++ (cppcheck)
<strong>Analysis Scope</strong>: Library modules only - src/ include/
<strong>Check Sets</strong>: cppcoreguidelines-<em>, cert-</em>, google-<em>, hicpp-</em> + All cppcheck rules (style, performance, portability, security, etc.) + MISRA C 2012 (applicable to C++)</p>
</div><div class="section"><h2 id="clang-tidy-analysis">clang-tidy Analysis</h2>
</div><div class="section"><h2 id="statistics">Statistics</h2>
<h3 id="summary">Summary</h3>
<ul>
<li><strong>Total Issues Found</strong>: 0</li>
<li><strong>Warnings</strong>: 0</li>
<li><strong>Errors</strong>: 0</li>
<li><strong>Files Analyzed</strong>: 9</li>
<li><strong>Unique Check Types</strong>: 1</li>
</ul>
<h3 id="suppressed-issues">Suppressed Issues</h3>
<ul>
<li><strong>Total Suppressed</strong>: 706534</li>
<li><strong>Non-user Code</strong>: 705517</li>
<li><strong>NOLINT Directives</strong>: 1017</li>
</ul>
<h3 id="issues-by-check-category">Issues by Check Category</h3>
<ul>
<li><strong>cert</strong>: 2 issues</li>
</ul>
<h3 id="files-with-issues">Files with Issues</h3>
<ul>
<li><strong>freertos_semaphore.hpp</strong>: 2 issues</li>
</ul>
<h3 id="analyzed-files">Analyzed Files</h3>
<ul>
<li>freertos.hpp</li>
<li>freertos_event_group.hpp</li>
<li>freertos_message_buffer.hpp</li>
<li>freertos_queue.hpp</li>
<li>freertos_semaphore.hpp</li>
<li>freertos_stream_buffer.hpp</li>
<li>freertos_sw_timer.hpp</li>
<li>freertos_task.cc</li>
<li>freertos_task.hpp</li>
</ul>
</div><div class="section"><h2 id="misra-c-analysis">MISRA C++ Analysis</h2>
<h3 id="summary_1">Summary</h3>
<ul>
<li><strong>Total MISRA Violations</strong>: 259</li>
<li><strong>Unique Rules Violated</strong>: 17</li>
<li><strong>Files Analyzed</strong>: 10</li>
<li><strong>Analysis Errors</strong>: 3</li>
<li><strong>Other Issues</strong>: 109</li>
</ul>
<h3 id="violations-by-severity">Violations by Severity</h3>
<ul>
<li><strong>Style</strong>: 259</li>
</ul>
<h3 id="violations-by-rule">Violations by Rule</h3>
<ul>
<li><strong>MISRA C 2012 Rule 10.4</strong>: 4 violation(s) - Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type</li>
<li><strong>MISRA C 2012 Rule 12.3</strong>: 36 violation(s) - The comma operator should not be used</li>
<li><strong>MISRA C 2012 Rule 13.4</strong>: 1 violation(s) - The result of an assignment operator should not be used</li>
<li><strong>MISRA C 2012 Rule 15.5</strong>: 17 violation(s) - A function should have a single point of exit at the end</li>
<li><strong>MISRA C 2012 Rule 16.3</strong>: 13 violation(s) - An unconditional break statement shall terminate every switch-clause</li>
<li><strong>MISRA C 2012 Rule 17.3</strong>: 7 violation(s) - A function shall not be declared implicitly</li>
<li><strong>MISRA C 2012 Rule 17.8</strong>: 14 violation(s) - A function parameter should not be modified</li>
<li><strong>MISRA C 2012 Rule 2.3</strong>: 2 violation(s) - A project should not contain unused type declarations</li>
<li><strong>MISRA C 2012 Rule 2.7</strong>: 15 violation(s) - There should be no unused parameters in functions</li>
<li><strong>MISRA C 2012 Rule 20.9</strong>: 25 violation(s) - All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation</li>
<li><strong>MISRA C 2012 Rule 21.2</strong>: 1 violation(s) - A reserved identifier or reserved macro name shall not be declared</li>
<li><strong>MISRA C 2012 Rule 3.1</strong>: 2 violation(s) - The character sequences /<em> and // shall not appear in /</em> comment */</li>
<li><strong>MISRA C 2012 Rule 5.8</strong>: 16 violation(s) - Identifiers that define objects or functions with external linkage shall be unique</li>
<li><strong>MISRA C 2012 Rule 8.2</strong>: 45 violation(s) - Function types shall be in prototype form with named parameters</li>
<li><strong>MISRA C 2012 Rule 8.5</strong>: 6 violation(s) - An external object or function shall be declared once in one and only one file</li>
<li><strong>MISRA C 2012 Rule 8.6</strong>: 40 violation(s) - An identifier with external linkage shall have exactly one external definition</li>
<li><strong>MISRA C 2012 Rule 8.7</strong>: 15 violation(s) - Functions and objects should not be defined with external linkage if they are referenced from only one translation unit</li>
</ul>
<h3 id="violations-by-file">Violations by File</h3>
<ul>
<li><strong>freertos_event_group.hpp</strong>: 12 violation(s)</li>
<li><strong>freertos_message_buffer.hpp</strong>: 21 violation(s)</li>
<li><strong>freertos_queue.hpp</strong>: 39 violation(s)</li>
<li><strong>freertos_semaphore.hpp</strong>: 81 violation(s)</li>
<li><strong>freertos_stream_buffer.hpp</strong>: 35 violation(s)</li>
<li><strong>freertos_sw_timer.hpp</strong>: 41 violation(s)</li>
<li><strong>freertos_task.cc</strong>: 4 violation(s)</li>
<li><strong>freertos_task.hpp</strong>: 26 violation(s)</li>
</ul>
<h3 id="detailed-violations-with-code-context">Detailed Violations with Code Context</h3>
<h4 id="misra-c-2012-rule-104-4-violations">MISRA C 2012 Rule 10.4 (4 violation(s))</h4>
<p><strong>Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type</strong></p>
<p>Arithmetic operations should be performed on operands of compatible types to avoid unexpected type conversions and potential loss of precision.</p>
<p><em>Rationale: Mixed-type arithmetic can lead to unexpected results due to implicit type conversions.</em></p>
<p><strong>Violation 1</strong>: freertos_semaphore.hpp:656:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     653:    */
     654:   BaseType_t unlock() {
     655:     auto rc = xSemaphoreGiveRecursive(m_semaphore);
&gt;&gt;&gt;  656:     if (rc &amp;&amp; m_recursions_count &gt; 0) {
     657:       m_recursions_count--;
     658:     }
     659:     return rc;
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_semaphore.hpp:671:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     668:    */
     669:   BaseType_t unlock_isr(BaseType_t &amp;high_priority_task_woken) {
     670:     auto rc = xSemaphoreGiveFromISR(m_semaphore, &amp;high_priority_task_woken);
&gt;&gt;&gt;  671:     if (rc &amp;&amp; m_recursions_count &gt; 0) {
     672:       m_recursions_count--;
     673:     }
     674:     return rc;
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_semaphore.hpp:685:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     682:   BaseType_t unlock_isr(void) {
     683:     BaseType_t high_priority_task_woken = pdFALSE;
     684:     auto rc = xSemaphoreGiveFromISR(m_semaphore, &amp;high_priority_task_woken);
&gt;&gt;&gt;  685:     if (rc &amp;&amp; m_recursions_count &gt; 0) {
     686:       m_recursions_count--;
     687:     }
     688:     return rc;
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_semaphore.hpp:762:55
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     759:    *
     760:    * @return bool true if the recursive mutex is locked, otherwise false.
     761:    */
&gt;&gt;&gt;  762:   bool locked(void) const { return m_recursions_count &gt; 0; }
     763:   /**
     764:    * @brief Get the number of recursions of the recursive mutex.
     765:    *
</code></pre></div>
<h4 id="misra-c-2012-rule-123-36-violations">MISRA C 2012 Rule 12.3 (36 violation(s))</h4>
<p><strong>The comma operator should not be used</strong></p>
<p>The comma operator can make code difficult to understand and maintain. Its use should be avoided except in specific contexts like for-loop expressions.</p>
<p><em>Rationale: The comma operator can obscure control flow and make code harder to read and debug.</em></p>
<p><strong>Violation 1</strong>: freertos_message_buffer.hpp:147:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     144:    * @param xTicksToWait timeout in ticks to wait for the message buffer to
     145:    * @return size_t number of bytes sent
     146:    */
&gt;&gt;&gt;  147:   template &lt;typename Rep, typename Period&gt;
     148:   size_t send(const void *pvTxData, size_t xDataLengthBytes,
     149:               const std::chrono::duration&lt;Rep, Period&gt; &amp;xTicksToWait) {
     150:     return send(
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_message_buffer.hpp:180:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     177:    * become available
     178:    * @return size_t number of bytes received
     179:    */
&gt;&gt;&gt;  180:   template &lt;typename Rep, typename Period&gt;
     181:   size_t receive(void *pvRxData, size_t xBufferLengthBytes,
     182:                  const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     183:     return receive(
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_message_buffer.hpp:94:35
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      91:  * @tparam MessageBufferSize size of the message buffer
      92:  * @tparam MessageBufferAllocator type of the message buffer allocator
      93:  */
&gt;&gt;&gt;   94: template &lt;size_t MessageBufferSize, typename MessageBufferAllocator&gt;
      95: class message_buffer {
      96:   MessageBufferAllocator m_allocator{};
      97:   MessageBufferHandle_t m_message_buffer{nullptr};
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_message_buffer.hpp:54:21
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      51:  */
      52: template &lt;size_t MessageBufferSize&gt; class static_message_buffer_allocator {
      53:   StaticMessageBuffer_t m_message_buffer_placeholder{};
&gt;&gt;&gt;   54:   std::array&lt;uint8_t, MessageBufferSize&gt; m_storage;
      55: 
      56: public:
      57:   static_message_buffer_allocator() = default;
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_queue.hpp:243:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     240:    * @return BaseType_t pdPASS if the item was successfully posted, otherwise
     241:    * errQUEUE_FULL.
     242:    */
&gt;&gt;&gt;  243:   template &lt;typename Rep, typename Period&gt;
     244:   BaseType_t send(const T &amp;item,
     245:                   const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     246:     return send(
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_queue.hpp:298:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     295:    * @return BaseType_t pdPASS if the item was successfully posted, otherwise
     296:    * errQUEUE_FULL.
     297:    */
&gt;&gt;&gt;  298:   template &lt;typename Rep, typename Period&gt;
     299:   BaseType_t send_back(const T &amp;item,
     300:                        const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     301:     return send_back(
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_queue.hpp:354:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     351:    * @return BaseType_t pdPASS if the item was successfully posted, otherwise
     352:    * errQUEUE_FULL.
     353:    */
&gt;&gt;&gt;  354:   template &lt;typename Rep, typename Period&gt;
     355:   BaseType_t send_front(const T &amp;item,
     356:                         const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     357:     return send_front(
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_queue.hpp:427:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     424:    * @return BaseType_t pdPASS if the item
     425:    * was successfully received, otherwise pdFALSE.
     426:    */
&gt;&gt;&gt;  427:   template &lt;typename Rep, typename Period&gt;
     428:   BaseType_t receive(T &amp;item,
     429:                      const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     430:     return receive(
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_queue.hpp:443:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     440:    * @return optional&lt;T&gt; The item received from the queue or std::nullopt if the
     441:    * queue is empty.
     442:    */
&gt;&gt;&gt;  443:   template &lt;typename Rep, typename Period&gt;
     444:   optional&lt;T&gt; receive(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     445:     return receive(pdMS_TO_TICKS(
     446:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout)
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_queue.hpp:580:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     577:    * @return BaseType_t pdPASS if the item was successfully peeked, otherwise
     578:    * pdFALSE.
     579:    */
&gt;&gt;&gt;  580:   template &lt;typename Rep, typename Period&gt;
     581:   BaseType_t peek(T &amp;item, const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     582:     return peek(
     583:         item, pdMS_TO_TICKS(
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_queue.hpp:638:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     635:    * @return optional&lt;T&gt; The item peeked from the queue or std::nullopt if the
     636:    * queue is empty.
     637:    */
&gt;&gt;&gt;  638:   template &lt;typename Rep, typename Period&gt;
     639:   optional&lt;T&gt; peek(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     640:     return peek(pdMS_TO_TICKS(
     641:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout)
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_queue.hpp:188:29
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     185:  * static_queue;
     186:  * ```
     187:  */
&gt;&gt;&gt;  188: template &lt;size_t QueueLength, typename T, typename QueueAllocator&gt; class queue {
     189:   QueueAllocator m_allocator{};
     190:   QueueHandle_t m_queue{nullptr};
     191: 
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_queue.hpp:56:21
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      53:  */
      54: template &lt;size_t QueueLength, typename T&gt; class static_queue_allocator {
      55:   StaticQueue_t m_queue_placeholder{};
&gt;&gt;&gt;   56:   std::array&lt;uint8_t, QueueLength * sizeof(T)&gt; m_storage;
      57: 
      58: public:
      59:   static_queue_allocator() = default;
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_semaphore.hpp:271:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     268:    * otherwise pdFALSE.
     269:    *
     270:    */
&gt;&gt;&gt;  271:   template &lt;typename Rep, typename Period&gt;
     272:   BaseType_t take(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     273:     return take(
     274:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout).count());
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_semaphore.hpp:393:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     390:    * otherwise pdFALSE.
     391:    *
     392:    */
&gt;&gt;&gt;  393:   template &lt;typename Rep, typename Period&gt;
     394:   BaseType_t take(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     395:     return take(
     396:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout).count());
</code></pre></div>
<p><strong>Violation 16</strong>: freertos_semaphore.hpp:586:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     583:    * @param timeout timeout to wait for the mutex.
     584:    * @return BaseType_t pdTRUE if the mutex was successfully locked,
     585:    */
&gt;&gt;&gt;  586:   template &lt;typename Rep, typename Period&gt;
     587:   BaseType_t lock(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     588:     return lock(
     589:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout).count());
</code></pre></div>
<p><strong>Violation 17</strong>: freertos_semaphore.hpp:739:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     736:    * @param timeout timeout to wait for the recursive mutex.
     737:    * @return BaseType_t pdTRUE if the recursive mutex was successfully locked,
     738:    */
&gt;&gt;&gt;  739:   template &lt;typename Rep, typename Period&gt;
     740:   BaseType_t lock(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     741:     return lock(
     742:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout).count());
</code></pre></div>
<p><strong>Violation 18</strong>: freertos_semaphore.hpp:827:23
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     824:    * @param mutex mutex to guard
     825:    */
     826:   explicit try_lock_guard(Mutex &amp;mutex)
&gt;&gt;&gt;  827:       : m_mutex{mutex}, m_lock_acquired{static_cast&lt;bool&gt;(m_mutex.try_lock())} {
     828:   }
     829:   /**
     830:    * @brief Destruct the try lock guard object and unlock the mutex.
</code></pre></div>
<p><strong>Violation 19</strong>: freertos_semaphore.hpp:921:23
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     918:    * @param ticks_to_wait timeout in ticks to wait for the mutex.
     919:    */
     920:   timeout_lock_guard(Mutex &amp;mutex, TickType_t ticks_to_wait)
&gt;&gt;&gt;  921:       : m_mutex{mutex},
     922:         m_lock_acquired{static_cast&lt;bool&gt;(m_mutex.lock(ticks_to_wait))} {}
     923:   /**
     924:    * @brief Construct a new timeout lock guard object
</code></pre></div>
<p><strong>Violation 20</strong>: freertos_semaphore.hpp:929:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     926:    * @param mutex mutex to guard
     927:    * @param timeout timeout to wait for the mutex.
     928:    */
&gt;&gt;&gt;  929:   template &lt;typename Rep, typename Period&gt;
     930:   timeout_lock_guard(Mutex &amp;mutex,
     931:                      const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout)
     932:       : m_mutex{mutex},
</code></pre></div>
<p><strong>Violation 21</strong>: freertos_semaphore.hpp:932:23
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     929:   template &lt;typename Rep, typename Period&gt;
     930:   timeout_lock_guard(Mutex &amp;mutex,
     931:                      const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout)
&gt;&gt;&gt;  932:       : m_mutex{mutex},
     933:         m_lock_acquired{static_cast&lt;bool&gt;(m_mutex.lock(
     934:             std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout)
     935:                 .count()))} {}
</code></pre></div>
<p><strong>Violation 22</strong>: freertos_sw_timer.hpp:130:58
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     127:    */
     128:   explicit timer(const char *name, const TickType_t period_ticks,
     129:                  UBaseType_t auto_reload, timer_callback_t &amp;&amp;callback)
&gt;&gt;&gt;  130:       : m_callback{std::move(callback)}, m_started{false},
     131:         m_timer{m_allocator.create(name, period_ticks, auto_reload, this,
     132:                                    callback_wrapper)} {
     133:     configASSERT(m_timer);
</code></pre></div>
<p><strong>Violation 23</strong>: freertos_sw_timer.hpp:145:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     142:    * @param auto_reload auto-reload flag
     143:    * @param callback callback routine
     144:    */
&gt;&gt;&gt;  145:   template &lt;typename Rep, typename Period&gt;
     146:   explicit timer(const char *name,
     147:                  const std::chrono::duration&lt;Rep, Period&gt; &amp;period,
     148:                  UBaseType_t auto_reload, timer_callback_t &amp;&amp;callback)
</code></pre></div>
<p><strong>Violation 24</strong>: freertos_sw_timer.hpp:254:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     251:    * @param timeout timeout to wait for the timer to start
     252:    * @return BaseType_t pdPASS if the timer was started successfully else pdFAIL
     253:    */
&gt;&gt;&gt;  254:   template &lt;typename Rep, typename Period&gt;
     255:   BaseType_t start(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     256:     return start(
     257:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout).count());
</code></pre></div>
<p><strong>Violation 25</strong>: freertos_sw_timer.hpp:313:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     310:    * @param timeout timeout to wait for the timer to stop
     311:    * @return BaseType_t pdPASS if the timer was stopped successfully else pdFAIL
     312:    */
&gt;&gt;&gt;  313:   template &lt;typename Rep, typename Period&gt;
     314:   BaseType_t stop(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     315:     return stop(
     316:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout).count());
</code></pre></div>
<p><strong>Violation 26</strong>: freertos_sw_timer.hpp:368:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     365:    * @param timeout timeout to wait for the timer to reset
     366:    * @return BaseType_t pdPASS if the timer was reset successfully else pdFAIL
     367:    */
&gt;&gt;&gt;  368:   template &lt;typename Rep, typename Period&gt;
     369:   BaseType_t reset(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     370:     return reset(
     371:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout).count());
</code></pre></div>
<p><strong>Violation 27</strong>: freertos_sw_timer.hpp:427:31
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     424:    * @return BaseType_t pdPASS if the timer period was changed successfully else
     425:    * pdFAIL
     426:    */
&gt;&gt;&gt;  427:   template &lt;typename RepPeriod, typename PeriodPeriod, typename RepTimeout,
     428:             typename PeriodTimeout&gt;
     429:   BaseType_t
     430:   period(const std::chrono::duration&lt;RepPeriod, PeriodPeriod&gt; &amp;new_period,
</code></pre></div>
<p><strong>Violation 28</strong>: freertos_sw_timer.hpp:467:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     464:    * @return BaseType_t pdPASS if the timer period was changed successfully else
     465:    * pdFAIL
     466:    */
&gt;&gt;&gt;  467:   template &lt;typename Rep, typename Period&gt;
     468:   BaseType_t period_isr(const std::chrono::duration&lt;Rep, Period&gt; &amp;new_period,
     469:                         BaseType_t &amp;high_priority_task_woken) {
     470:     return period_isr(
</code></pre></div>
<p><strong>Violation 29</strong>: freertos_sw_timer.hpp:497:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     494:    * @return BaseType_t pdPASS if the timer period was changed successfully else
     495:    * pdFAIL
     496:    */
&gt;&gt;&gt;  497:   template &lt;typename Rep, typename Period&gt;
     498:   BaseType_t period_isr(const std::chrono::duration&lt;Rep, Period&gt; &amp;new_period) {
     499:     return period_isr(
     500:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(new_period)
</code></pre></div>
<p><strong>Violation 30</strong>: freertos_event_group.hpp:181:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     178:    * @param timeout timeout to wait for the bits
     179:    * @return EventBits_t value of the event group after the call returns
     180:    */
&gt;&gt;&gt;  181:   template &lt;typename Rep, typename Period&gt;
     182:   EventBits_t wait_bits(const EventBits_t bits_to_wait_for,
     183:                         const BaseType_t clear_on_exit,
     184:                         const BaseType_t wait_for_all_bits,
</code></pre></div>
<p><strong>Violation 31</strong>: freertos_event_group.hpp:223:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     220:     return xEventGroupSync(m_event_group, bits_to_set, bits_to_wait_for,
     221:                            ticks_to_wait);
     222:   }
&gt;&gt;&gt;  223:   template &lt;typename Rep, typename Period&gt;
     224:   EventBits_t sync(const EventBits_t bits_to_set,
     225:                    const EventBits_t bits_to_wait_for,
     226:                    const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
</code></pre></div>
<p><strong>Violation 32</strong>: freertos_stream_buffer.hpp:156:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     153:    * stream buffer, otherwise errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY if there was
     154:    * insufficient memory available to copy the data into the stream buffer.
     155:    */
&gt;&gt;&gt;  156:   template &lt;typename Rep, typename Period&gt;
     157:   BaseType_t send(const void *data, size_t data_size,
     158:                   const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     159:     return send(
</code></pre></div>
<p><strong>Violation 33</strong>: freertos_stream_buffer.hpp:194:30
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     191:    * stream buffer, otherwise errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY if there was
     192:    * insufficient memory available to copy the data into the stream buffer.
     193:    */
&gt;&gt;&gt;  194:   template &lt;typename Iterator, typename Rep, typename Period&gt;
     195:   BaseType_t send(Iterator begin, Iterator end,
     196:                   const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     197:     return send(&amp;*begin, std::distance(begin, end), timeout);
</code></pre></div>
<p><strong>Violation 34</strong>: freertos_stream_buffer.hpp:294:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     291:    * @param timeout Duration to wait for the data to be copied into the buffer.
     292:    * @return size_t Number of bytes received.
     293:    */
&gt;&gt;&gt;  294:   template &lt;typename Rep, typename Period&gt;
     295:   size_t receive(void *data, size_t data_size,
     296:                  const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     297:     return receive(
</code></pre></div>
<p><strong>Violation 35</strong>: freertos_stream_buffer.hpp:96:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      93:  * @tparam StreamBufferSize size of the stream buffer
      94:  * @tparam StreamBufferAllocator type of the stream buffer allocator
      95:  */
&gt;&gt;&gt;   96: template &lt;size_t StreamBufferSize, typename StreamBufferAllocator&gt;
      97: class stream_buffer {
      98:   StreamBufferAllocator m_allocator{};
      99:   StreamBufferHandle_t m_stream_buffer{nullptr};
</code></pre></div>
<p><strong>Violation 36</strong>: freertos_stream_buffer.hpp:55:21
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      52:  */
      53: template &lt;size_t StreamBufferSize&gt; class static_stream_buffer_allocator {
      54:   StaticStreamBuffer_t m_stream_buffer_placeholder{};
&gt;&gt;&gt;   55:   std::array&lt;uint8_t, StreamBufferSize&gt; m_storage;
      56: 
      57: public:
      58:   static_stream_buffer_allocator() = default;
</code></pre></div>
<h4 id="misra-c-2012-rule-134-1-violations">MISRA C 2012 Rule 13.4 (1 violation(s))</h4>
<p><strong>The result of an assignment operator should not be used</strong></p>
<p>Assignment expressions should not be used as sub-expressions. Assignments should be separate statements to improve readability and avoid confusion.</p>
<p><em>Rationale: Using assignment results as expressions can make code harder to read and may hide logical errors.</em></p>
<p><strong>Violation 1</strong>: freertos_queue.hpp:199:45
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     196:    * @param registred_name Name of the queue, which will be used to register it
     197:    * in the queue registry. If nullptr, the queue will not be registered.
     198:    */
&gt;&gt;&gt;  199:   explicit queue(const char *registred_name = nullptr)
     200:       : m_queue{m_allocator.create()} {
     201:     configASSERT(m_queue);
     202:     if (registred_name != nullptr) {
</code></pre></div>
<h4 id="misra-c-2012-rule-155-17-violations">MISRA C 2012 Rule 15.5 (17 violation(s))</h4>
<p><strong>A function should have a single point of exit at the end</strong></p>
<p>Functions should have one return statement at the end rather than multiple return points throughout the function body. This improves code clarity and makes debugging easier.</p>
<p><em>Rationale: Single exit points make functions easier to understand, debug, and maintain.</em></p>
<p><strong>Violation 1</strong>: freertos_queue.hpp:414:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     411:   optional&lt;T&gt; receive(TickType_t ticks_to_wait) {
     412:     T item;
     413:     if (xQueueReceive(m_queue, &amp;item, ticks_to_wait) == pdPASS) {
&gt;&gt;&gt;  414:       return item;
     415:     }
     416:     return {};
     417:   }
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_queue.hpp:487:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     484:     BaseType_t higher_priority_task_woken = pdFALSE;
     485:     if (xQueueReceiveFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken) ==
     486:         pdPASS) {
&gt;&gt;&gt;  487:       return item;
     488:     }
     489:     return {};
     490:   }
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_queue.hpp:626:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     623:   optional&lt;T&gt; peek(TickType_t ticks_to_wait) {
     624:     T item;
     625:     if (xQueuePeek(m_queue, &amp;item, ticks_to_wait) == pdPASS) {
&gt;&gt;&gt;  626:       return item;
     627:     }
     628:     return {};
     629:   }
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_queue.hpp:658:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     655:     BaseType_t higher_priority_task_woken = pdFALSE;
     656:     if (xQueuePeekFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken) ==
     657:         pdPASS) {
&gt;&gt;&gt;  658:       return item;
     659:     }
     660:     return {};
     661:   }
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_sw_timer.hpp:237:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     234:    */
     235:   BaseType_t start(const TickType_t ticks_to_wait = portMAX_DELAY) {
     236:     if (!m_timer) {
&gt;&gt;&gt;  237:       return pdFAIL;
     238:     }
     239:     auto rc = xTimerStart(m_timer, ticks_to_wait);
     240:     if (rc) {
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_sw_timer.hpp:269:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     266:    */
     267:   BaseType_t start_isr(BaseType_t &amp;high_priority_task_woken) {
     268:     if (!m_timer) {
&gt;&gt;&gt;  269:       return pdFAIL;
     270:     }
     271:     auto rc = xTimerStartFromISR(m_timer, &amp;high_priority_task_woken);
     272:     if (rc) {
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_sw_timer.hpp:296:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     293:    */
     294:   BaseType_t stop(const TickType_t ticks_to_wait = portMAX_DELAY) {
     295:     if (!m_timer) {
&gt;&gt;&gt;  296:       return pdFAIL;
     297:     }
     298:     auto rc = xTimerStop(m_timer, ticks_to_wait);
     299:     if (rc) {
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_sw_timer.hpp:328:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     325:    */
     326:   BaseType_t stop_isr(BaseType_t &amp;high_priority_task_woken) {
     327:     if (!m_timer) {
&gt;&gt;&gt;  328:       return pdFAIL;
     329:     }
     330:     auto rc = xTimerStopFromISR(m_timer, &amp;high_priority_task_woken);
     331:     if (rc) {
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_sw_timer.hpp:355:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     352:    */
     353:   BaseType_t reset(const TickType_t ticks_to_wait = portMAX_DELAY) {
     354:     if (!m_timer) {
&gt;&gt;&gt;  355:       return pdFAIL;
     356:     }
     357:     return xTimerReset(m_timer, ticks_to_wait);
     358:   }
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_sw_timer.hpp:383:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     380:    */
     381:   BaseType_t reset_isr(BaseType_t &amp;high_priority_task_woken) {
     382:     if (!m_timer) {
&gt;&gt;&gt;  383:       return pdFAIL;
     384:     }
     385:     return xTimerResetFromISR(m_timer, &amp;high_priority_task_woken);
     386:   }
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_sw_timer.hpp:410:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     407:   BaseType_t period(const TickType_t new_period_ticks,
     408:                     const TickType_t ticks_to_wait = portMAX_DELAY) {
     409:     if (!m_timer) {
&gt;&gt;&gt;  410:       return pdFAIL;
     411:     }
     412:     return xTimerChangePeriod(m_timer, new_period_ticks, ticks_to_wait);
     413:   }
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_sw_timer.hpp:450:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     447:   BaseType_t period_isr(const TickType_t new_period_ticks,
     448:                         BaseType_t &amp;high_priority_task_woken) {
     449:     if (!m_timer) {
&gt;&gt;&gt;  450:       return pdFAIL;
     451:     }
     452:     return xTimerChangePeriodFromISR(m_timer, new_period_ticks,
     453:                                      &amp;high_priority_task_woken);
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_sw_timer.hpp:516:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     513:    */
     514:   TickType_t period_ticks(void) const {
     515:     if (!m_timer) {
&gt;&gt;&gt;  516:       return 0;
     517:     }
     518:     return xTimerGetPeriod(m_timer);
     519:   }
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_sw_timer.hpp:556:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     553:    */
     554:   TickType_t remaining_ticks(void) const {
     555:     if (m_timer) {
&gt;&gt;&gt;  556:       return xTimerGetExpiryTime(m_timer) - xTaskGetTickCount();
     557:     } else {
     558:       return 0;
     559:     }
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_sw_timer.hpp:558:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     555:     if (m_timer) {
     556:       return xTimerGetExpiryTime(m_timer) - xTaskGetTickCount();
     557:     } else {
&gt;&gt;&gt;  558:       return 0;
     559:     }
     560:   }
     561:   /**
</code></pre></div>
<p><strong>Violation 16</strong>: freertos_sw_timer.hpp:578:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     575:    */
     576:   BaseType_t running(void) const {
     577:     if (!m_timer) {
&gt;&gt;&gt;  578:       return pdFALSE;
     579:     }
     580:     return xTimerIsTimerActive(m_timer);
     581:   }
</code></pre></div>
<p><strong>Violation 17</strong>: freertos_sw_timer.hpp:589:7
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     586:    */
     587:   const char *name(void) const {
     588:     if (!m_timer) {
&gt;&gt;&gt;  589:       return nullptr;
     590:     }
     591:     return pcTimerGetName(m_timer);
     592:   }
</code></pre></div>
<h4 id="misra-c-2012-rule-163-13-violations">MISRA C 2012 Rule 16.3 (13 violation(s))</h4>
<p><strong>An unconditional break statement shall terminate every switch-clause</strong></p>
<p>Every case in a switch statement should end with a break statement to prevent fall-through behavior, unless fall-through is explicitly intended and documented.</p>
<p><em>Rationale: Missing break statements can cause unintended fall-through behavior that leads to bugs.</em></p>
<p><strong>Violation 1</strong>: freertos_message_buffer.hpp:57:39
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      54:   std::array&lt;uint8_t, MessageBufferSize&gt; m_storage;
      55: 
      56: public:
&gt;&gt;&gt;   57:   static_message_buffer_allocator() = default;
      58:   ~static_message_buffer_allocator() = default;
      59:   static_message_buffer_allocator(const static_message_buffer_allocator &amp;) =
      60:       delete;
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_message_buffer.hpp:58:40
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      55: 
      56: public:
      57:   static_message_buffer_allocator() = default;
&gt;&gt;&gt;   58:   ~static_message_buffer_allocator() = default;
      59:   static_message_buffer_allocator(const static_message_buffer_allocator &amp;) =
      60:       delete;
      61:   static_message_buffer_allocator(static_message_buffer_allocator &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_queue.hpp:59:30
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      56:   std::array&lt;uint8_t, QueueLength * sizeof(T)&gt; m_storage;
      57: 
      58: public:
&gt;&gt;&gt;   59:   static_queue_allocator() = default;
      60:   ~static_queue_allocator() = default;
      61:   static_queue_allocator(const static_queue_allocator &amp;) = delete;
      62:   static_queue_allocator(static_queue_allocator &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_queue.hpp:60:31
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      57: 
      58: public:
      59:   static_queue_allocator() = default;
&gt;&gt;&gt;   60:   ~static_queue_allocator() = default;
      61:   static_queue_allocator(const static_queue_allocator &amp;) = delete;
      62:   static_queue_allocator(static_queue_allocator &amp;&amp;) = delete;
      63: 
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_semaphore.hpp:56:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      53:   StaticSemaphore_t m_semaphore_placeholder{};
      54: 
      55: public:
&gt;&gt;&gt;   56:   static_semaphore_allocator() = default;
      57:   ~static_semaphore_allocator() = default;
      58:   static_semaphore_allocator(const static_semaphore_allocator &amp;) = delete;
      59:   static_semaphore_allocator(static_semaphore_allocator &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_semaphore.hpp:57:35
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      54: 
      55: public:
      56:   static_semaphore_allocator() = default;
&gt;&gt;&gt;   57:   ~static_semaphore_allocator() = default;
      58:   static_semaphore_allocator(const static_semaphore_allocator &amp;) = delete;
      59:   static_semaphore_allocator(static_semaphore_allocator &amp;&amp;) = delete;
      60: 
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_sw_timer.hpp:63:33
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      60:   StaticTimer_t m_timer_placeholder{};
      61: 
      62: public:
&gt;&gt;&gt;   63:   static_sw_timer_allocator() = default;
      64:   ~static_sw_timer_allocator() = default;
      65:   static_sw_timer_allocator(const static_sw_timer_allocator &amp;) = delete;
      66:   static_sw_timer_allocator(static_sw_timer_allocator &amp;&amp;) = default;
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_sw_timer.hpp:64:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      61: 
      62: public:
      63:   static_sw_timer_allocator() = default;
&gt;&gt;&gt;   64:   ~static_sw_timer_allocator() = default;
      65:   static_sw_timer_allocator(const static_sw_timer_allocator &amp;) = delete;
      66:   static_sw_timer_allocator(static_sw_timer_allocator &amp;&amp;) = default;
      67: 
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_sw_timer.hpp:66:61
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      63:   static_sw_timer_allocator() = default;
      64:   ~static_sw_timer_allocator() = default;
      65:   static_sw_timer_allocator(const static_sw_timer_allocator &amp;) = delete;
&gt;&gt;&gt;   66:   static_sw_timer_allocator(static_sw_timer_allocator &amp;&amp;) = default;
      67: 
      68:   static_sw_timer_allocator &amp;
      69:   operator=(const static_sw_timer_allocator &amp;) = delete;
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_event_group.hpp:54:36
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      51:   StaticEventGroup_t m_event_group_placeholder{};
      52: 
      53: public:
&gt;&gt;&gt;   54:   static_event_group_allocator() = default;
      55:   ~static_event_group_allocator() = default;
      56:   static_event_group_allocator(const static_event_group_allocator &amp;) = delete;
      57:   static_event_group_allocator(static_event_group_allocator &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_event_group.hpp:55:37
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      52: 
      53: public:
      54:   static_event_group_allocator() = default;
&gt;&gt;&gt;   55:   ~static_event_group_allocator() = default;
      56:   static_event_group_allocator(const static_event_group_allocator &amp;) = delete;
      57:   static_event_group_allocator(static_event_group_allocator &amp;&amp;) = delete;
      58: 
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_stream_buffer.hpp:58:38
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      55:   std::array&lt;uint8_t, StreamBufferSize&gt; m_storage;
      56: 
      57: public:
&gt;&gt;&gt;   58:   static_stream_buffer_allocator() = default;
      59:   ~static_stream_buffer_allocator() = default;
      60:   static_stream_buffer_allocator(const static_stream_buffer_allocator &amp;) =
      61:       delete;
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_stream_buffer.hpp:59:39
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      56: 
      57: public:
      58:   static_stream_buffer_allocator() = default;
&gt;&gt;&gt;   59:   ~static_stream_buffer_allocator() = default;
      60:   static_stream_buffer_allocator(const static_stream_buffer_allocator &amp;) =
      61:       delete;
      62:   static_stream_buffer_allocator(static_stream_buffer_allocator &amp;&amp;) = delete;
</code></pre></div>
<h4 id="misra-c-2012-rule-173-7-violations">MISRA C 2012 Rule 17.3 (7 violation(s))</h4>
<p><strong>A function shall not be declared implicitly</strong></p>
<p>All functions should be explicitly declared before use. Implicit function declarations can lead to type mismatches and undefined behavior.</p>
<p><em>Rationale: Implicit function declarations can cause type mismatches and make code harder to understand and maintain.</em></p>
<p><strong>Violation 1</strong>: freertos_queue.hpp:413:9
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     410:    */
     411:   optional&lt;T&gt; receive(TickType_t ticks_to_wait) {
     412:     T item;
&gt;&gt;&gt;  413:     if (xQueueReceive(m_queue, &amp;item, ticks_to_wait) == pdPASS) {
     414:       return item;
     415:     }
     416:     return {};
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_queue.hpp:485:9
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     482:   optional&lt;T&gt; receive_isr(void) {
     483:     T item;
     484:     BaseType_t higher_priority_task_woken = pdFALSE;
&gt;&gt;&gt;  485:     if (xQueueReceiveFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken) ==
     486:         pdPASS) {
     487:       return item;
     488:     }
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_queue.hpp:625:9
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     622:    */
     623:   optional&lt;T&gt; peek(TickType_t ticks_to_wait) {
     624:     T item;
&gt;&gt;&gt;  625:     if (xQueuePeek(m_queue, &amp;item, ticks_to_wait) == pdPASS) {
     626:       return item;
     627:     }
     628:     return {};
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_queue.hpp:656:9
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     653:   optional&lt;T&gt; peek_isr(void) {
     654:     T item;
     655:     BaseType_t higher_priority_task_woken = pdFALSE;
&gt;&gt;&gt;  656:     if (xQueuePeekFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken) ==
     657:         pdPASS) {
     658:       return item;
     659:     }
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_sw_timer.hpp:184:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     181:     if (m_timer) {
     182:       auto rc = xTimerDelete(m_timer, portMAX_DELAY);
     183:       if (rc == pdPASS) {
&gt;&gt;&gt;  184:         while (xTimerIsTimerActive(m_timer) != pdFALSE) {
     185:           vTaskDelay(pdMS_TO_TICKS(1));
     186:         }
     187:       }
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_sw_timer.hpp:199:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     196:       }
     197:       auto rc = xTimerStop(src.m_timer, portMAX_DELAY);
     198:       if (rc == pdPASS) {
&gt;&gt;&gt;  199:         while (xTimerIsTimerActive(src.m_timer) != pdFALSE) {
     200:           vTaskDelay(pdMS_TO_TICKS(1));
     201:         }
     202:         auto name = pcTimerGetName(src.m_timer);
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_sw_timer.hpp:207:18
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     204:         auto auto_reload = uxTimerGetReloadMode(src.m_timer);
     205:         rc = xTimerDelete(src.m_timer, portMAX_DELAY);
     206:         if (rc == pdPASS) {
&gt;&gt;&gt;  207:           while (xTimerIsTimerActive(src.m_timer) != pdFALSE) {
     208:             vTaskDelay(pdMS_TO_TICKS(1));
     209:           }
     210:           src.m_timer = nullptr;
</code></pre></div>
<h4 id="misra-c-2012-rule-178-14-violations">MISRA C 2012 Rule 17.8 (14 violation(s))</h4>
<p><strong>A function parameter should not be modified</strong></p>
<p>Function parameters should not be modified within the function body. If modification is needed, use a local copy of the parameter.</p>
<p><em>Rationale: Modifying parameters can make function behavior less predictable and harder to understand.</em></p>
<p><strong>Violation 1</strong>: freertos_semaphore.hpp:234:50
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     231:    * otherwise pdFALSE.
     232:    *
     233:    */
&gt;&gt;&gt;  234:   BaseType_t take(const TickType_t ticks_to_wait = portMAX_DELAY) {
     235:     return xSemaphoreTake(m_semaphore, ticks_to_wait);
     236:   }
     237:   /**
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_semaphore.hpp:356:50
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     353:    * otherwise pdFALSE.
     354:    *
     355:    */
&gt;&gt;&gt;  356:   BaseType_t take(const TickType_t ticks_to_wait = portMAX_DELAY) {
     357:     return xSemaphoreTake(m_semaphore, ticks_to_wait);
     358:   }
     359:   /**
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_semaphore.hpp:453:17
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     450:    * @return counting_semaphore&amp; reference to the counting semaphore.
     451:    */
     452:   counting_semaphore &amp;operator+=(UBaseType_t count) {
&gt;&gt;&gt;  453:     while (count--) {
     454:       give();
     455:     }
     456:     return *this;
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_semaphore.hpp:544:50
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     541:    * @param ticks_to_wait timeout in ticks to wait for the mutex.
     542:    * @return BaseType_t pdTRUE if the mutex was successfully locked,
     543:    */
&gt;&gt;&gt;  544:   BaseType_t lock(const TickType_t ticks_to_wait = portMAX_DELAY) {
     545:     auto rc = xSemaphoreTake(m_semaphore, ticks_to_wait);
     546:     if (rc) {
     547:       m_locked = true;
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_semaphore.hpp:697:50
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     694:    * @param ticks_to_wait timeout in ticks to wait for the recursive mutex.
     695:    * @return BaseType_t pdTRUE if the recursive mutex was successfully locked,
     696:    */
&gt;&gt;&gt;  697:   BaseType_t lock(const TickType_t ticks_to_wait = portMAX_DELAY) {
     698:     auto rc = xSemaphoreTakeRecursive(m_semaphore, ticks_to_wait);
     699:     if (rc) {
     700:       m_recursions_count++;
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_sw_timer.hpp:235:51
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     232:    * @param ticks_to_wait timeout in ticks to wait for the timer to start
     233:    * @return BaseType_t pdPASS if the timer was started successfully else pdFAIL
     234:    */
&gt;&gt;&gt;  235:   BaseType_t start(const TickType_t ticks_to_wait = portMAX_DELAY) {
     236:     if (!m_timer) {
     237:       return pdFAIL;
     238:     }
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_sw_timer.hpp:294:50
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     291:    * @param ticks_to_wait timeout in ticks to wait for the timer to stop
     292:    * @return BaseType_t pdPASS if the timer was stopped successfully else pdFAIL
     293:    */
&gt;&gt;&gt;  294:   BaseType_t stop(const TickType_t ticks_to_wait = portMAX_DELAY) {
     295:     if (!m_timer) {
     296:       return pdFAIL;
     297:     }
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_sw_timer.hpp:353:51
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     350:    * @param ticks_to_wait timeout in ticks to wait for the timer to reset
     351:    * @return BaseType_t pdPASS if the timer was reset successfully else pdFAIL
     352:    */
&gt;&gt;&gt;  353:   BaseType_t reset(const TickType_t ticks_to_wait = portMAX_DELAY) {
     354:     if (!m_timer) {
     355:       return pdFAIL;
     356:     }
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_sw_timer.hpp:408:52
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     405:    * pdFAIL
     406:    */
     407:   BaseType_t period(const TickType_t new_period_ticks,
&gt;&gt;&gt;  408:                     const TickType_t ticks_to_wait = portMAX_DELAY) {
     409:     if (!m_timer) {
     410:       return pdFAIL;
     411:     }
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_stream_buffer.hpp:141:38
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     138:    * insufficient memory available to copy the data into the stream buffer.
     139:    */
     140:   BaseType_t send(const void *data, size_t data_size,
&gt;&gt;&gt;  141:                   TickType_t timeout = portMAX_DELAY) {
     142:     return xStreamBufferSend(m_stream_buffer, data, data_size, timeout);
     143:   }
     144:   /**
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_stream_buffer.hpp:178:38
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     175:    */
     176:   template &lt;typename Iterator&gt;
     177:   BaseType_t send(Iterator begin, Iterator end,
&gt;&gt;&gt;  178:                   TickType_t timeout = portMAX_DELAY) {
     179:     return send(&amp;*begin, std::distance(begin, end), timeout);
     180:   }
     181:   /**
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_stream_buffer.hpp:281:37
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     278:    * @return size_t Number of bytes received.
     279:    */
     280:   size_t receive(void *data, size_t data_size,
&gt;&gt;&gt;  281:                  TickType_t timeout = portMAX_DELAY) {
     282:     return xStreamBufferReceive(m_stream_buffer, data, data_size, timeout);
     283:   }
     284:   /**
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_stream_buffer.hpp:84:58
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      81:  */
      82: template &lt;size_t StreamBufferSize&gt; class dynamic_stream_buffer_allocator {
      83: public:
&gt;&gt;&gt;   84:   StreamBufferHandle_t create(size_t trigger_level_bytes = 1) {
      85:     return xStreamBufferCreate(StreamBufferSize, trigger_level_bytes);
      86:   }
      87: };
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_stream_buffer.hpp:69:58
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      66:   static_stream_buffer_allocator &amp;
      67:   operator=(static_stream_buffer_allocator &amp;&amp;) = delete;
      68: 
&gt;&gt;&gt;   69:   StreamBufferHandle_t create(size_t trigger_level_bytes = 1) {
      70:     return xStreamBufferCreateStatic(StreamBufferSize, trigger_level_bytes,
      71:                                      m_storage.data(),
      72:                                      &amp;m_stream_buffer_placeholder);
</code></pre></div>
<h4 id="misra-c-2012-rule-23-2-violations">MISRA C 2012 Rule 2.3 (2 violation(s))</h4>
<p><strong>A project should not contain unused type declarations</strong></p>
<p>Unused type declarations may indicate incomplete code or can be removed to simplify the codebase. This rule helps identify dead code and improves maintainability.</p>
<p><em>Rationale: Unused declarations can confuse developers and increase compilation time unnecessarily.</em></p>
<p><strong>Violation 1</strong>: freertos_queue.hpp:47:0
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      44: 
      45: namespace freertos {
      46: 
&gt;&gt;&gt;   47: using std::optional;
      48: 
      49: #if configSUPPORT_STATIC_ALLOCATION
      50: /**
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_queue.hpp:47:0
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      44: 
      45: namespace freertos {
      46: 
&gt;&gt;&gt;   47: using std::optional;
      48: 
      49: #if configSUPPORT_STATIC_ALLOCATION
      50: /**
</code></pre></div>
<h4 id="misra-c-2012-rule-27-15-violations">MISRA C 2012 Rule 2.7 (15 violation(s))</h4>
<p><strong>There should be no unused parameters in functions</strong></p>
<p>Function parameters that are not used may indicate an error in the implementation or can be removed to clarify the interface. If a parameter must remain for interface compatibility, it should be explicitly marked as unused.</p>
<p><em>Rationale: Unused parameters can indicate incomplete implementations or interface issues and should be explicitly handled.</em></p>
<p><strong>Violation 1</strong>: freertos_semaphore.hpp:295:43
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     292:    * @param max_count maximum count of the counting semaphore.
     293:    *
     294:    */
&gt;&gt;&gt;  295:   explicit counting_semaphore(UBaseType_t max_count = 1)
     296:       : m_semaphore{m_allocator.create_counting(max_count)} {
     297:     configASSERT(m_semaphore);
     298:   }
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_semaphore.hpp:424:23
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     421:    */
     422:   // NOLINTNEXTLINE(cert-dcl21-cpp): RAII class, copy is deleted -
     423:   // post-increment returns reference instead of copy
&gt;&gt;&gt;  424:   counting_semaphore &amp;operator++(int) {
     425:     give();
     426:     return *this;
     427:   }
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_semaphore.hpp:436:23
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     433:    */
     434:   // NOLINTNEXTLINE(cert-dcl21-cpp): RAII class, copy is deleted -
     435:   // post-decrement returns reference instead of copy
&gt;&gt;&gt;  436:   counting_semaphore &amp;operator--(int) {
     437:     take();
     438:     return *this;
     439:   }
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_semaphore.hpp:787:30
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     784:    *
     785:    * @param mutex mutex to guard
     786:    */
&gt;&gt;&gt;  787:   explicit lock_guard(Mutex &amp;mutex) : m_mutex{mutex} { m_mutex.lock(); }
     788: 
     789:   /**
     790:    * @brief Destruct the lock guard object and unlock the mutex.
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_semaphore.hpp:826:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     823:    *
     824:    * @param mutex mutex to guard
     825:    */
&gt;&gt;&gt;  826:   explicit try_lock_guard(Mutex &amp;mutex)
     827:       : m_mutex{mutex}, m_lock_acquired{static_cast&lt;bool&gt;(m_mutex.try_lock())} {
     828:   }
     829:   /**
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_semaphore.hpp:870:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     867:    *
     868:    * @param mutex mutex to guard
     869:    */
&gt;&gt;&gt;  870:   explicit lock_guard_isr(Mutex &amp;mutex) : m_mutex{mutex} {
     871:     m_mutex.lock_isr(m_high_priority_task_woken);
     872:   }
     873:   /**
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_semaphore.hpp:920:29
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     917:    * @param mutex mutex to guard
     918:    * @param ticks_to_wait timeout in ticks to wait for the mutex.
     919:    */
&gt;&gt;&gt;  920:   timeout_lock_guard(Mutex &amp;mutex, TickType_t ticks_to_wait)
     921:       : m_mutex{mutex},
     922:         m_lock_acquired{static_cast&lt;bool&gt;(m_mutex.lock(ticks_to_wait))} {}
     923:   /**
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_semaphore.hpp:930:29
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     927:    * @param timeout timeout to wait for the mutex.
     928:    */
     929:   template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt;  930:   timeout_lock_guard(Mutex &amp;mutex,
     931:                      const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout)
     932:       : m_mutex{mutex},
     933:         m_lock_acquired{static_cast&lt;bool&gt;(m_mutex.lock(
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_semaphore.hpp:931:64
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     928:    */
     929:   template &lt;typename Rep, typename Period&gt;
     930:   timeout_lock_guard(Mutex &amp;mutex,
&gt;&gt;&gt;  931:                      const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout)
     932:       : m_mutex{mutex},
     933:         m_lock_acquired{static_cast&lt;bool&gt;(m_mutex.lock(
     934:             std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout)
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_sw_timer.hpp:128:30
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     125:    * @param auto_reload auto-reload flag
     126:    * @param callback callback routine
     127:    */
&gt;&gt;&gt;  128:   explicit timer(const char *name, const TickType_t period_ticks,
     129:                  UBaseType_t auto_reload, timer_callback_t &amp;&amp;callback)
     130:       : m_callback{std::move(callback)}, m_started{false},
     131:         m_timer{m_allocator.create(name, period_ticks, auto_reload, this,
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_sw_timer.hpp:129:30
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     126:    * @param callback callback routine
     127:    */
     128:   explicit timer(const char *name, const TickType_t period_ticks,
&gt;&gt;&gt;  129:                  UBaseType_t auto_reload, timer_callback_t &amp;&amp;callback)
     130:       : m_callback{std::move(callback)}, m_started{false},
     131:         m_timer{m_allocator.create(name, period_ticks, auto_reload, this,
     132:                                    callback_wrapper)} {
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_sw_timer.hpp:146:30
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     143:    * @param callback callback routine
     144:    */
     145:   template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt;  146:   explicit timer(const char *name,
     147:                  const std::chrono::duration&lt;Rep, Period&gt; &amp;period,
     148:                  UBaseType_t auto_reload, timer_callback_t &amp;&amp;callback)
     149:       : timer{name,
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_sw_timer.hpp:147:60
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     144:    */
     145:   template &lt;typename Rep, typename Period&gt;
     146:   explicit timer(const char *name,
&gt;&gt;&gt;  147:                  const std::chrono::duration&lt;Rep, Period&gt; &amp;period,
     148:                  UBaseType_t auto_reload, timer_callback_t &amp;&amp;callback)
     149:       : timer{name,
     150:               static_cast&lt;TickType_t&gt;(
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_sw_timer.hpp:148:30
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     145:   template &lt;typename Rep, typename Period&gt;
     146:   explicit timer(const char *name,
     147:                  const std::chrono::duration&lt;Rep, Period&gt; &amp;period,
&gt;&gt;&gt;  148:                  UBaseType_t auto_reload, timer_callback_t &amp;&amp;callback)
     149:       : timer{name,
     150:               static_cast&lt;TickType_t&gt;(
     151:                   std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(period)
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_stream_buffer.hpp:108:33
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     105:    * @param trigger_level_bytes the number of bytes that must be in the stream
     106:    * buffer before a task that is blocked on a read operation will be unblocked
     107:    */
&gt;&gt;&gt;  108:   explicit stream_buffer(size_t trigger_level_bytes = 1)
     109:       : m_stream_buffer{m_allocator.create(trigger_level_bytes)} {
     110:     configASSERT(m_stream_buffer);
     111:   }
</code></pre></div>
<h4 id="misra-c-2012-rule-209-25-violations">MISRA C 2012 Rule 20.9 (25 violation(s))</h4>
<p><strong>All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation</strong></p>
<p>Preprocessor identifiers used in conditional compilation should be explicitly defined to avoid undefined behavior in preprocessor evaluation.</p>
<p><em>Rationale: Undefined preprocessor identifiers evaluate to 0, which may not be the intended behavior.</em></p>
<p><strong>Violation 1</strong>: freertos_message_buffer.hpp:46:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      43: 
      44: namespace freertos {
      45: 
&gt;&gt;&gt;   46: #if configSUPPORT_STATIC_ALLOCATION
      47: /**
      48:  * @brief An allocator for the message buffer that uses a static memory
      49:  * allocation.
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_message_buffer.hpp:74:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      71:   }
      72: };
      73: #endif
&gt;&gt;&gt;   74: #if configSUPPORT_DYNAMIC_ALLOCATION
      75: /**
      76:  * @brief An allocator for the message buffer that uses a dynamic memory
      77:  * allocation.
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_message_buffer.hpp:219:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     216:   BaseType_t full(void) { return xMessageBufferIsFull(m_message_buffer); }
     217: };
     218: 
&gt;&gt;&gt;  219: #if configSUPPORT_STATIC_ALLOCATION
     220: /**
     221:  * @brief Namespace for the FreeRTOS message buffer with static memory
     222:  * allocation
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_message_buffer.hpp:237:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     234:     freertos::static_message_buffer_allocator&lt;MessageBufferSize&gt;&gt;;
     235: } // namespace sa
     236: #endif
&gt;&gt;&gt;  237: #if configSUPPORT_DYNAMIC_ALLOCATION
     238: /**
     239:  * @brief Namespace for the FreeRTOS message buffer with dynamic memory
     240:  * allocation
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_queue.hpp:49:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      46: 
      47: using std::optional;
      48: 
&gt;&gt;&gt;   49: #if configSUPPORT_STATIC_ALLOCATION
      50: /**
      51:  * @brief An allocator for the queue that uses a static memory allocation.
      52:  *
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_queue.hpp:73:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      70:   }
      71: };
      72: #endif
&gt;&gt;&gt;   73: #if configSUPPORT_DYNAMIC_ALLOCATION
      74: /**
      75:  * @brief An allocator for the queue that uses a dynamic memory allocation.
      76:  *
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_queue.hpp:687:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     684:   }
     685: };
     686: 
&gt;&gt;&gt;  687: #if configSUPPORT_STATIC_ALLOCATION
     688: /**
     689:  * @brief A namespace for the FreeRTOS queue with a static memory allocation.
     690:  *
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_queue.hpp:702:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     699:     freertos::queue&lt;QueueLength, T, static_queue_allocator&lt;QueueLength, T&gt;&gt;;
     700: } // namespace sa
     701: #endif
&gt;&gt;&gt;  702: #if configSUPPORT_DYNAMIC_ALLOCATION
     703: /**
     704:  * @brief A namespace for the FreeRTOS queue with a dynamic memory allocation.
     705:  *
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_semaphore.hpp:47:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      44: 
      45: namespace freertos {
      46: 
&gt;&gt;&gt;   47: #if configSUPPORT_STATIC_ALLOCATION
      48: /**
      49:  * @brief An allocator for the semaphore that uses a static memory allocation.
      50:  *
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_semaphore.hpp:80:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      77:   }
      78: };
      79: #endif
&gt;&gt;&gt;   80: #if configSUPPORT_DYNAMIC_ALLOCATION
      81: /**
      82:  * @brief An allocator for the semaphore that uses a dynamic memory allocation.
      83:  *
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_semaphore.hpp:960:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     957:   bool locked(void) const { return m_lock_acquired &amp;&amp; m_mutex.locked(); }
     958: };
     959: 
&gt;&gt;&gt;  960: #if configSUPPORT_STATIC_ALLOCATION
     961: /**
     962:  * @brief A wrapper for the FreeRTOS binary semaphore with static memory
     963:  * allocation.
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_semaphore.hpp:992:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     989:     freertos::recursive_mutex&lt;freertos::static_semaphore_allocator&gt;;
     990: } // namespace sa
     991: #endif
&gt;&gt;&gt;  992: #if configSUPPORT_DYNAMIC_ALLOCATION
     993: /**
     994:  * @brief A wrapper for the FreeRTOS binary semaphore with dynamic memory
     995:  * allocation.
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_sw_timer.hpp:49:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      46: 
      47: namespace freertos {
      48: 
&gt;&gt;&gt;   49: #if configUSE_TIMERS
      50: 
      51: using std::function;
      52: 
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_sw_timer.hpp:53:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      50: 
      51: using std::function;
      52: 
&gt;&gt;&gt;   53: #if configSUPPORT_STATIC_ALLOCATION
      54: /**
      55:  * @brief An allocator for the software timer that uses a static memory
      56:  * allocation.
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_sw_timer.hpp:595:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     592:   }
     593: };
     594: 
&gt;&gt;&gt;  595: #if configSUPPORT_STATIC_ALLOCATION
     596: /**
     597:  * @brief Namespace for the kernel objects static memory allocation.
     598:  *
</code></pre></div>
<p><strong>Violation 16</strong>: freertos_sw_timer.hpp:80:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      77:   }
      78: };
      79: #endif
&gt;&gt;&gt;   80: #if configSUPPORT_DYNAMIC_ALLOCATION
      81: /**
      82:  * @brief An allocator for the software timer that uses a dynamic memory
      83:  * allocation.
</code></pre></div>
<p><strong>Violation 17</strong>: freertos_sw_timer.hpp:608:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     605: using timer = freertos::timer&lt;freertos::static_sw_timer_allocator&gt;;
     606: } // namespace sa
     607: #endif
&gt;&gt;&gt;  608: #if configSUPPORT_DYNAMIC_ALLOCATION
     609: /**
     610:  * @brief Namespace for the kernel objects dynamic memory allocation.
     611:  *
</code></pre></div>
<p><strong>Violation 18</strong>: freertos_event_group.hpp:45:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      42: 
      43: namespace freertos {
      44: 
&gt;&gt;&gt;   45: #if configSUPPORT_STATIC_ALLOCATION
      46: /**
      47:  * @brief An allocator for the event group that uses a static memory allocation.
      48:  *
</code></pre></div>
<p><strong>Violation 19</strong>: freertos_event_group.hpp:68:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      65:   }
      66: };
      67: #endif
&gt;&gt;&gt;   68: #if configSUPPORT_DYNAMIC_ALLOCATION
      69: /**
      70:  * @brief An allocator for the event group that uses a dynamic memory
      71:  * allocation.
</code></pre></div>
<p><strong>Violation 20</strong>: freertos_event_group.hpp:235:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     232:   }
     233: };
     234: 
&gt;&gt;&gt;  235: #if configSUPPORT_STATIC_ALLOCATION
     236: /**
     237:  * @brief Namespace for aliases of RTOS kernel objects that use a static memory
     238:  *
</code></pre></div>
<p><strong>Violation 21</strong>: freertos_event_group.hpp:249:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     246:     freertos::event_group&lt;freertos::static_event_group_allocator&gt;;
     247: } // namespace sa
     248: #endif
&gt;&gt;&gt;  249: #if configSUPPORT_DYNAMIC_ALLOCATION
     250: /**
     251:  * @brief Namespace for aliases of RTOS kernel objects that use a dynamic memory
     252:  *
</code></pre></div>
<p><strong>Violation 22</strong>: freertos_stream_buffer.hpp:47:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      44: 
      45: namespace freertos {
      46: 
&gt;&gt;&gt;   47: #if configSUPPORT_STATIC_ALLOCATION
      48: /**
      49:  * @brief An allocator for the stream buffer that uses a static memory
      50:  * allocation.
</code></pre></div>
<p><strong>Violation 23</strong>: freertos_stream_buffer.hpp:76:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      73:   }
      74: };
      75: #endif
&gt;&gt;&gt;   76: #if configSUPPORT_DYNAMIC_ALLOCATION
      77: /**
      78:  * @brief An allocator for the stream buffer that uses a dynamic memory
      79:  * allocation.
</code></pre></div>
<p><strong>Violation 24</strong>: freertos_stream_buffer.hpp:387:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     384:   BaseType_t full(void) { return xStreamBufferIsFull(m_stream_buffer); }
     385: };
     386: 
&gt;&gt;&gt;  387: #if configSUPPORT_STATIC_ALLOCATION
     388: /**
     389:  * @brief Namespace for the FreeRTOS stream buffer with static memory allocation
     390:  *
</code></pre></div>
<p><strong>Violation 25</strong>: freertos_stream_buffer.hpp:404:2
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     401:     freertos::static_stream_buffer_allocator&lt;StreamBufferSize&gt;&gt;;
     402: } // namespace sa
     403: #endif
&gt;&gt;&gt;  404: #if configSUPPORT_DYNAMIC_ALLOCATION
     405: /**
     406:  * @brief Namespace for the FreeRTOS stream buffer with dynamic memory
     407:  * allocation
</code></pre></div>
<h4 id="misra-c-2012-rule-212-1-violations">MISRA C 2012 Rule 21.2 (1 violation(s))</h4>
<p><strong>A reserved identifier or reserved macro name shall not be declared</strong></p>
<p>Identifiers reserved by the C standard (such as those beginning with underscore) should not be used in user code to avoid conflicts with implementation-defined behavior.</p>
<p><em>Rationale: Using reserved identifiers can conflict with compiler and standard library implementations.</em></p>
<p><strong>Violation 1</strong>: freertos_stream_buffer.hpp:346:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     343:    *
     344:    * @return size_t Number of bytes free in the stream buffer.
     345:    */
&gt;&gt;&gt;  346:   size_t free(void) { return xStreamBufferSpacesAvailable(m_stream_buffer); }
     347:   /**
     348:    * @brief Reset the stream buffer to the cleared state.
     349:    * @ref https://www.freertos.org/xStreamBufferReset.html
</code></pre></div>
<h4 id="misra-c-2012-rule-31-2-violations">MISRA C 2012 Rule 3.1 (2 violation(s))</h4>
<p><strong>The character sequences /<em> and // shall not appear in /</em> comment */</strong></p>
<p>Comment delimiters should not appear within comments to avoid confusion about comment boundaries and prevent accidental code commenting.</p>
<p><em>Rationale: Nested comment sequences can lead to unexpected comment boundaries and code being accidentally commented out.</em></p>
<p><strong>Violation 1</strong>: freertos_queue.hpp:84:1
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      81: };
      82: #endif
      83: 
&gt;&gt;&gt;   84: /**
      85:  * @brief A modern C++ wrapper for FreeRTOS queues with type safety.
      86:  *
      87:  * This class provides a type-safe, RAII wrapper around FreeRTOS queues for
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_semaphore.hpp:98:1
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      95: };
      96: #endif
      97: 
&gt;&gt;&gt;   98: /**
      99:  * @brief A modern C++ wrapper for FreeRTOS binary semaphores.
     100:  *
     101:  * Binary semaphores are used for both mutual exclusion and task
</code></pre></div>
<h4 id="misra-c-2012-rule-58-16-violations">MISRA C 2012 Rule 5.8 (16 violation(s))</h4>
<p><strong>Identifiers that define objects or functions with external linkage shall be unique</strong></p>
<p>External identifiers must be unique to avoid linking errors and undefined behavior when linking multiple translation units.</p>
<p><em>Rationale: Non-unique external identifiers can cause linking errors and unpredictable behavior in multi-file projects.</em></p>
<p><strong>Violation 1</strong>: freertos_task.hpp:219:20
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     216:    * @param priority  priority of the task
     217:    * @param task_routine  task routine function
     218:    */
&gt;&gt;&gt;  219:   task(const char *name, UBaseType_t priority, task_routine_t &amp;&amp;task_routine)
     220:       : m_allocator{}, m_taskRoutine{task_routine},
     221:         m_hTask{m_allocator.create(task_exec, name, priority, this)} {}
     222:   /**
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_task.hpp:848:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     845:    *
     846:    * @return const char*  task name
     847:    */
&gt;&gt;&gt;  848:   const char *name(void) const { return m_task.name(); }
     849: // Task notification API
     850: #if configUSE_TASK_NOTIFICATIONS
     851:   /**
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_task.hpp:219:20
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     216:    * @param priority  priority of the task
     217:    * @param task_routine  task routine function
     218:    */
&gt;&gt;&gt;  219:   task(const char *name, UBaseType_t priority, task_routine_t &amp;&amp;task_routine)
     220:       : m_allocator{}, m_taskRoutine{task_routine},
     221:         m_hTask{m_allocator.create(task_exec, name, priority, this)} {}
     222:   /**
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_task.hpp:848:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     845:    *
     846:    * @return const char*  task name
     847:    */
&gt;&gt;&gt;  848:   const char *name(void) const { return m_task.name(); }
     849: // Task notification API
     850: #if configUSE_TASK_NOTIFICATIONS
     851:   /**
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_semaphore.hpp:452:46
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     449:    * @param count the number of times to give the counting semaphore.
     450:    * @return counting_semaphore&amp; reference to the counting semaphore.
     451:    */
&gt;&gt;&gt;  452:   counting_semaphore &amp;operator+=(UBaseType_t count) {
     453:     while (count--) {
     454:       give();
     455:     }
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_semaphore.hpp:445:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     442:    *
     443:    * @return UBaseType_t count of the counting semaphore.
     444:    */
&gt;&gt;&gt;  445:   UBaseType_t count() { return uxSemaphoreGetCount(m_semaphore); }
     446:   /**
     447:    * @brief Give the counting semaphore.
     448:    *
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_semaphore.hpp:787:30
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     784:    *
     785:    * @param mutex mutex to guard
     786:    */
&gt;&gt;&gt;  787:   explicit lock_guard(Mutex &amp;mutex) : m_mutex{mutex} { m_mutex.lock(); }
     788: 
     789:   /**
     790:    * @brief Destruct the lock guard object and unlock the mutex.
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_semaphore.hpp:486:4
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     483:    * created.
     484:    *
     485:    */
&gt;&gt;&gt;  486:   ~mutex(void) {
     487:     if (m_semaphore) {
     488:       vSemaphoreDelete(m_semaphore);
     489:     }
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_semaphore.hpp:530:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     527:    * @return BaseType_t pdTRUE if the mutex was successfully unlocked,
     528:    */
     529:   BaseType_t unlock_isr(void) {
&gt;&gt;&gt;  530:     BaseType_t high_priority_task_woken = pdFALSE;
     531:     auto rc = xSemaphoreGiveFromISR(m_semaphore, &amp;high_priority_task_woken);
     532:     if (rc) {
     533:       m_locked = false;
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_semaphore.hpp:891:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     888:    * @return BaseType_t pdTRUE if the high priority task was woken, otherwise
     889:    * pdFALSE.
     890:    */
&gt;&gt;&gt;  891:   BaseType_t high_priority_task_woken(void) const {
     892:     return m_high_priority_task_woken;
     893:   }
     894:   /**
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_semaphore.hpp:452:46
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     449:    * @param count the number of times to give the counting semaphore.
     450:    * @return counting_semaphore&amp; reference to the counting semaphore.
     451:    */
&gt;&gt;&gt;  452:   counting_semaphore &amp;operator+=(UBaseType_t count) {
     453:     while (count--) {
     454:       give();
     455:     }
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_semaphore.hpp:486:4
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     483:    * created.
     484:    *
     485:    */
&gt;&gt;&gt;  486:   ~mutex(void) {
     487:     if (m_semaphore) {
     488:       vSemaphoreDelete(m_semaphore);
     489:     }
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_semaphore.hpp:530:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     527:    * @return BaseType_t pdTRUE if the mutex was successfully unlocked,
     528:    */
     529:   BaseType_t unlock_isr(void) {
&gt;&gt;&gt;  530:     BaseType_t high_priority_task_woken = pdFALSE;
     531:     auto rc = xSemaphoreGiveFromISR(m_semaphore, &amp;high_priority_task_woken);
     532:     if (rc) {
     533:       m_locked = false;
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_semaphore.hpp:891:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     888:    * @return BaseType_t pdTRUE if the high priority task was woken, otherwise
     889:    * pdFALSE.
     890:    */
&gt;&gt;&gt;  891:   BaseType_t high_priority_task_woken(void) const {
     892:     return m_high_priority_task_woken;
     893:   }
     894:   /**
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_task.hpp:219:20
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     216:    * @param priority  priority of the task
     217:    * @param task_routine  task routine function
     218:    */
&gt;&gt;&gt;  219:   task(const char *name, UBaseType_t priority, task_routine_t &amp;&amp;task_routine)
     220:       : m_allocator{}, m_taskRoutine{task_routine},
     221:         m_hTask{m_allocator.create(task_exec, name, priority, this)} {}
     222:   /**
</code></pre></div>
<p><strong>Violation 16</strong>: freertos_task.hpp:848:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     845:    *
     846:    * @return const char*  task name
     847:    */
&gt;&gt;&gt;  848:   const char *name(void) const { return m_task.name(); }
     849: // Task notification API
     850: #if configUSE_TASK_NOTIFICATIONS
     851:   /**
</code></pre></div>
<h4 id="misra-c-2012-rule-82-45-violations">MISRA C 2012 Rule 8.2 (45 violation(s))</h4>
<p><strong>Function types shall be in prototype form with named parameters</strong></p>
<p>Function declarations should include parameter names in addition to types. This improves code readability and helps with documentation.</p>
<p><em>Rationale: Named parameters in function prototypes make the interface clearer and improve code documentation.</em></p>
<p><strong>Violation 1</strong>: freertos_message_buffer.hpp:104:26
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     101:    * @brief Construct a new message buffer object
     102:    *
     103:    */
&gt;&gt;&gt;  104:   explicit message_buffer() : m_message_buffer{m_allocator.create()} {
     105:     configASSERT(m_message_buffer);
     106:   }
     107:   message_buffer(const message_buffer &amp;) = delete;
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_message_buffer.hpp:107:24
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     104:   explicit message_buffer() : m_message_buffer{m_allocator.create()} {
     105:     configASSERT(m_message_buffer);
     106:   }
&gt;&gt;&gt;  107:   message_buffer(const message_buffer &amp;) = delete;
     108:   message_buffer(message_buffer &amp;&amp;src) = delete;
     109:   /**
     110:    * @brief Destruct the message buffer object and delete the message buffer
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_message_buffer.hpp:120:35
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     117:     }
     118:   }
     119: 
&gt;&gt;&gt;  120:   message_buffer &amp;operator=(const message_buffer &amp;) = delete;
     121:   message_buffer &amp;operator=(message_buffer &amp;&amp;src) = delete;
     122: 
     123:   /**
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_queue.hpp:206:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     203:       vQueueAddToRegistry(m_queue, registred_name);
     204:     }
     205:   }
&gt;&gt;&gt;  206:   queue(const queue &amp;) = delete;
     207:   queue(queue &amp;&amp;src) = delete;
     208:   ~queue(void) {
     209:     if (m_queue) {
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_queue.hpp:218:26
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     215:     }
     216:   }
     217: 
&gt;&gt;&gt;  218:   queue &amp;operator=(const queue &amp;) = delete;
     219:   queue &amp;operator=(queue &amp;&amp;src) = delete;
     220: 
     221:   /**
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_semaphore.hpp:174:19
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     171:    * @brief Construct a new binary semaphore object
     172:    *
     173:    */
&gt;&gt;&gt;  174:   binary_semaphore() : m_semaphore{m_allocator.create_binary()} {
     175:     configASSERT(m_semaphore);
     176:   }
     177:   binary_semaphore(const binary_semaphore &amp;) = delete;
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_semaphore.hpp:177:26
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     174:   binary_semaphore() : m_semaphore{m_allocator.create_binary()} {
     175:     configASSERT(m_semaphore);
     176:   }
&gt;&gt;&gt;  177:   binary_semaphore(const binary_semaphore &amp;) = delete;
     178:   binary_semaphore(binary_semaphore &amp;&amp;src) = delete;
     179:   /**
     180:    * @brief Destruct the binary semaphore object and
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_semaphore.hpp:190:37
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     187:     }
     188:   }
     189: 
&gt;&gt;&gt;  190:   binary_semaphore &amp;operator=(const binary_semaphore &amp;) = delete;
     191:   binary_semaphore &amp;operator=(binary_semaphore &amp;&amp;src) = delete;
     192: 
     193:   /**
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_semaphore.hpp:201:18
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     198:    * otherwise pdFALSE.
     199:    *
     200:    */
&gt;&gt;&gt;  201:   BaseType_t give() { return xSemaphoreGive(m_semaphore); }
     202:   /**
     203:    * @brief Give the binary semaphore from an ISR.
     204:    * @ref https://www.freertos.org/a00124.html
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_semaphore.hpp:299:28
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     296:       : m_semaphore{m_allocator.create_counting(max_count)} {
     297:     configASSERT(m_semaphore);
     298:   }
&gt;&gt;&gt;  299:   counting_semaphore(const counting_semaphore &amp;) = delete;
     300:   counting_semaphore(counting_semaphore &amp;&amp;src) = delete;
     301:   /**
     302:    * @brief Destruct the counting semaphore object and
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_semaphore.hpp:312:39
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     309:     }
     310:   }
     311: 
&gt;&gt;&gt;  312:   counting_semaphore &amp;operator=(const counting_semaphore &amp;) = delete;
     313:   counting_semaphore &amp;operator=(counting_semaphore &amp;&amp;src) = delete;
     314: 
     315:   /**
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_semaphore.hpp:323:18
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     320:    * otherwise pdFALSE.
     321:    *
     322:    */
&gt;&gt;&gt;  323:   BaseType_t give() { return xSemaphoreGive(m_semaphore); }
     324:   /**
     325:    * @brief Give the counting semaphore from an ISR.
     326:    * @ref https://www.freertos.org/a00124.html
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_semaphore.hpp:403:33
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     400:    *
     401:    * @return counting_semaphore&amp; reference to the counting semaphore.
     402:    */
&gt;&gt;&gt;  403:   counting_semaphore &amp;operator++() {
     404:     give();
     405:     return *this;
     406:   }
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_semaphore.hpp:412:33
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     409:    *
     410:    * @return counting_semaphore&amp; reference to the counting semaphore.
     411:    */
&gt;&gt;&gt;  412:   counting_semaphore &amp;operator--() {
     413:     take();
     414:     return *this;
     415:   }
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_semaphore.hpp:445:20
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     442:    *
     443:    * @return UBaseType_t count of the counting semaphore.
     444:    */
&gt;&gt;&gt;  445:   UBaseType_t count() { return uxSemaphoreGetCount(m_semaphore); }
     446:   /**
     447:    * @brief Give the counting semaphore.
     448:    *
</code></pre></div>
<p><strong>Violation 16</strong>: freertos_semaphore.hpp:476:8
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     473:    * @brief Construct a new mutex object
     474:    *
     475:    */
&gt;&gt;&gt;  476:   mutex() : m_semaphore{m_allocator.create_mutex()}, m_locked{false} {
     477:     configASSERT(m_semaphore);
     478:   }
     479:   mutex(const mutex &amp;) = delete;
</code></pre></div>
<p><strong>Violation 17</strong>: freertos_semaphore.hpp:479:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     476:   mutex() : m_semaphore{m_allocator.create_mutex()}, m_locked{false} {
     477:     configASSERT(m_semaphore);
     478:   }
&gt;&gt;&gt;  479:   mutex(const mutex &amp;) = delete;
     480:   mutex(mutex &amp;&amp;src) = delete;
     481:   /**
     482:    * @brief Destruct the mutex object and delete the mutex instance if it was
</code></pre></div>
<p><strong>Violation 18</strong>: freertos_semaphore.hpp:492:26
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     489:     }
     490:   }
     491: 
&gt;&gt;&gt;  492:   mutex &amp;operator=(const mutex &amp;) = delete;
     493:   mutex &amp;operator=(mutex &amp;&amp;src) = delete;
     494: 
     495:   /**
</code></pre></div>
<p><strong>Violation 19</strong>: freertos_semaphore.hpp:501:20
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     498:    *
     499:    * @return BaseType_t pdTRUE if the mutex was successfully unlocked,
     500:    */
&gt;&gt;&gt;  501:   BaseType_t unlock() {
     502:     auto rc = xSemaphoreGive(m_semaphore);
     503:     if (rc) {
     504:       m_locked = false;
</code></pre></div>
<p><strong>Violation 20</strong>: freertos_semaphore.hpp:597:22
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     594:    *
     595:    * @return BaseType_t pdTRUE if the mutex was successfully locked,
     596:    */
&gt;&gt;&gt;  597:   BaseType_t try_lock() {
     598:     auto rc = xSemaphoreTake(m_semaphore, 0);
     599:     if (rc) {
     600:       m_locked = true;
</code></pre></div>
<p><strong>Violation 21</strong>: freertos_semaphore.hpp:628:18
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     625:    * @brief Construct a new recursive mutex object
     626:    *
     627:    */
&gt;&gt;&gt;  628:   recursive_mutex() : m_semaphore{m_allocator.create_recursive_mutex()} {
     629:     configASSERT(m_semaphore);
     630:   }
     631:   recursive_mutex(const recursive_mutex &amp;) = delete;
</code></pre></div>
<p><strong>Violation 22</strong>: freertos_semaphore.hpp:631:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     628:   recursive_mutex() : m_semaphore{m_allocator.create_recursive_mutex()} {
     629:     configASSERT(m_semaphore);
     630:   }
&gt;&gt;&gt;  631:   recursive_mutex(const recursive_mutex &amp;) = delete;
     632:   recursive_mutex(recursive_mutex &amp;&amp;src) = delete;
     633:   /**
     634:    * @brief Destruct the recursive mutex object and delete the recursive mutex
</code></pre></div>
<p><strong>Violation 23</strong>: freertos_semaphore.hpp:644:36
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     641:     }
     642:   }
     643: 
&gt;&gt;&gt;  644:   recursive_mutex &amp;operator=(const recursive_mutex &amp;) = delete;
     645:   recursive_mutex &amp;operator=(recursive_mutex &amp;&amp;src) = delete;
     646: 
     647:   /**
</code></pre></div>
<p><strong>Violation 24</strong>: freertos_semaphore.hpp:654:20
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     651:    * @return BaseType_t pdTRUE if the recursive mutex was successfully unlocked,
     652:    * otherwise pdFALSE.
     653:    */
&gt;&gt;&gt;  654:   BaseType_t unlock() {
     655:     auto rc = xSemaphoreGiveRecursive(m_semaphore);
     656:     if (rc &amp;&amp; m_recursions_count &gt; 0) {
     657:       m_recursions_count--;
</code></pre></div>
<p><strong>Violation 25</strong>: freertos_semaphore.hpp:750:22
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     747:    *
     748:    * @return BaseType_t pdTRUE if the recursive mutex was successfully locked,
     749:    */
&gt;&gt;&gt;  750:   BaseType_t try_lock() {
     751:     auto rc = xSemaphoreTakeRecursive(m_semaphore, 0);
     752:     if (rc) {
     753:       m_recursions_count++;
</code></pre></div>
<p><strong>Violation 26</strong>: freertos_semaphore.hpp:796:20
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     793:   ~lock_guard(void) { m_mutex.unlock(); }
     794: 
     795:   // Delete copy and move operations for RAII safety
&gt;&gt;&gt;  796:   lock_guard(const lock_guard &amp;) = delete;
     797:   lock_guard(lock_guard &amp;&amp;) = delete;
     798:   lock_guard &amp;operator=(const lock_guard &amp;) = delete;
     799:   lock_guard &amp;operator=(lock_guard &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 27</strong>: freertos_semaphore.hpp:797:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     794: 
     795:   // Delete copy and move operations for RAII safety
     796:   lock_guard(const lock_guard &amp;) = delete;
&gt;&gt;&gt;  797:   lock_guard(lock_guard &amp;&amp;) = delete;
     798:   lock_guard &amp;operator=(const lock_guard &amp;) = delete;
     799:   lock_guard &amp;operator=(lock_guard &amp;&amp;) = delete;
     800: 
</code></pre></div>
<p><strong>Violation 28</strong>: freertos_semaphore.hpp:798:31
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     795:   // Delete copy and move operations for RAII safety
     796:   lock_guard(const lock_guard &amp;) = delete;
     797:   lock_guard(lock_guard &amp;&amp;) = delete;
&gt;&gt;&gt;  798:   lock_guard &amp;operator=(const lock_guard &amp;) = delete;
     799:   lock_guard &amp;operator=(lock_guard &amp;&amp;) = delete;
     800: 
     801:   /**
</code></pre></div>
<p><strong>Violation 29</strong>: freertos_semaphore.hpp:799:25
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     796:   lock_guard(const lock_guard &amp;) = delete;
     797:   lock_guard(lock_guard &amp;&amp;) = delete;
     798:   lock_guard &amp;operator=(const lock_guard &amp;) = delete;
&gt;&gt;&gt;  799:   lock_guard &amp;operator=(lock_guard &amp;&amp;) = delete;
     800: 
     801:   /**
     802:    * @brief Checks if the mutex is locked.
</code></pre></div>
<p><strong>Violation 30</strong>: freertos_semaphore.hpp:840:24
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     837:   }
     838: 
     839:   // Delete copy and move operations for RAII safety
&gt;&gt;&gt;  840:   try_lock_guard(const try_lock_guard &amp;) = delete;
     841:   try_lock_guard(try_lock_guard &amp;&amp;) = delete;
     842:   try_lock_guard &amp;operator=(const try_lock_guard &amp;) = delete;
     843:   try_lock_guard &amp;operator=(try_lock_guard &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 31</strong>: freertos_semaphore.hpp:841:18
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     838: 
     839:   // Delete copy and move operations for RAII safety
     840:   try_lock_guard(const try_lock_guard &amp;) = delete;
&gt;&gt;&gt;  841:   try_lock_guard(try_lock_guard &amp;&amp;) = delete;
     842:   try_lock_guard &amp;operator=(const try_lock_guard &amp;) = delete;
     843:   try_lock_guard &amp;operator=(try_lock_guard &amp;&amp;) = delete;
     844: 
</code></pre></div>
<p><strong>Violation 32</strong>: freertos_semaphore.hpp:842:35
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     839:   // Delete copy and move operations for RAII safety
     840:   try_lock_guard(const try_lock_guard &amp;) = delete;
     841:   try_lock_guard(try_lock_guard &amp;&amp;) = delete;
&gt;&gt;&gt;  842:   try_lock_guard &amp;operator=(const try_lock_guard &amp;) = delete;
     843:   try_lock_guard &amp;operator=(try_lock_guard &amp;&amp;) = delete;
     844: 
     845:   /**
</code></pre></div>
<p><strong>Violation 33</strong>: freertos_semaphore.hpp:843:29
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     840:   try_lock_guard(const try_lock_guard &amp;) = delete;
     841:   try_lock_guard(try_lock_guard &amp;&amp;) = delete;
     842:   try_lock_guard &amp;operator=(const try_lock_guard &amp;) = delete;
&gt;&gt;&gt;  843:   try_lock_guard &amp;operator=(try_lock_guard &amp;&amp;) = delete;
     844: 
     845:   /**
     846:    * @brief Checks if the mutex is locked.
</code></pre></div>
<p><strong>Violation 34</strong>: freertos_semaphore.hpp:880:24
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     877:   ~lock_guard_isr(void) { m_mutex.unlock_isr(m_high_priority_task_woken); }
     878: 
     879:   // Delete copy and move operations for RAII safety
&gt;&gt;&gt;  880:   lock_guard_isr(const lock_guard_isr &amp;) = delete;
     881:   lock_guard_isr(lock_guard_isr &amp;&amp;) = delete;
     882:   lock_guard_isr &amp;operator=(const lock_guard_isr &amp;) = delete;
     883:   lock_guard_isr &amp;operator=(lock_guard_isr &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 35</strong>: freertos_semaphore.hpp:881:18
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     878: 
     879:   // Delete copy and move operations for RAII safety
     880:   lock_guard_isr(const lock_guard_isr &amp;) = delete;
&gt;&gt;&gt;  881:   lock_guard_isr(lock_guard_isr &amp;&amp;) = delete;
     882:   lock_guard_isr &amp;operator=(const lock_guard_isr &amp;) = delete;
     883:   lock_guard_isr &amp;operator=(lock_guard_isr &amp;&amp;) = delete;
     884: 
</code></pre></div>
<p><strong>Violation 36</strong>: freertos_semaphore.hpp:882:35
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     879:   // Delete copy and move operations for RAII safety
     880:   lock_guard_isr(const lock_guard_isr &amp;) = delete;
     881:   lock_guard_isr(lock_guard_isr &amp;&amp;) = delete;
&gt;&gt;&gt;  882:   lock_guard_isr &amp;operator=(const lock_guard_isr &amp;) = delete;
     883:   lock_guard_isr &amp;operator=(lock_guard_isr &amp;&amp;) = delete;
     884: 
     885:   /**
</code></pre></div>
<p><strong>Violation 37</strong>: freertos_semaphore.hpp:883:29
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     880:   lock_guard_isr(const lock_guard_isr &amp;) = delete;
     881:   lock_guard_isr(lock_guard_isr &amp;&amp;) = delete;
     882:   lock_guard_isr &amp;operator=(const lock_guard_isr &amp;) = delete;
&gt;&gt;&gt;  883:   lock_guard_isr &amp;operator=(lock_guard_isr &amp;&amp;) = delete;
     884: 
     885:   /**
     886:    * @brief Checks if high priority task was woken.
</code></pre></div>
<p><strong>Violation 38</strong>: freertos_semaphore.hpp:947:28
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     944:   }
     945: 
     946:   // Delete copy and move operations for RAII safety
&gt;&gt;&gt;  947:   timeout_lock_guard(const timeout_lock_guard &amp;) = delete;
     948:   timeout_lock_guard(timeout_lock_guard &amp;&amp;) = delete;
     949:   timeout_lock_guard &amp;operator=(const timeout_lock_guard &amp;) = delete;
     950:   timeout_lock_guard &amp;operator=(timeout_lock_guard &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 39</strong>: freertos_semaphore.hpp:948:22
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     945: 
     946:   // Delete copy and move operations for RAII safety
     947:   timeout_lock_guard(const timeout_lock_guard &amp;) = delete;
&gt;&gt;&gt;  948:   timeout_lock_guard(timeout_lock_guard &amp;&amp;) = delete;
     949:   timeout_lock_guard &amp;operator=(const timeout_lock_guard &amp;) = delete;
     950:   timeout_lock_guard &amp;operator=(timeout_lock_guard &amp;&amp;) = delete;
     951: 
</code></pre></div>
<p><strong>Violation 40</strong>: freertos_semaphore.hpp:949:39
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     946:   // Delete copy and move operations for RAII safety
     947:   timeout_lock_guard(const timeout_lock_guard &amp;) = delete;
     948:   timeout_lock_guard(timeout_lock_guard &amp;&amp;) = delete;
&gt;&gt;&gt;  949:   timeout_lock_guard &amp;operator=(const timeout_lock_guard &amp;) = delete;
     950:   timeout_lock_guard &amp;operator=(timeout_lock_guard &amp;&amp;) = delete;
     951: 
     952:   /**
</code></pre></div>
<p><strong>Violation 41</strong>: freertos_semaphore.hpp:950:33
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     947:   timeout_lock_guard(const timeout_lock_guard &amp;) = delete;
     948:   timeout_lock_guard(timeout_lock_guard &amp;&amp;) = delete;
     949:   timeout_lock_guard &amp;operator=(const timeout_lock_guard &amp;) = delete;
&gt;&gt;&gt;  950:   timeout_lock_guard &amp;operator=(timeout_lock_guard &amp;&amp;) = delete;
     951: 
     952:   /**
     953:    * @brief Checks if the mutex is locked.
</code></pre></div>
<p><strong>Violation 42</strong>: freertos_event_group.hpp:95:21
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      92:    *
      93:    */
      94:   event_group(void) : m_event_group(m_allocator.create()) {}
&gt;&gt;&gt;   95:   event_group(const event_group &amp;) = delete;
      96:   event_group(event_group &amp;&amp;other) = delete;
      97:   /**
      98:    * @brief Destruct the event group object and delete the event group instance
</code></pre></div>
<p><strong>Violation 43</strong>: freertos_event_group.hpp:108:32
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     105:     }
     106:   }
     107: 
&gt;&gt;&gt;  108:   event_group &amp;operator=(const event_group &amp;) = delete;
     109:   event_group &amp;operator=(event_group &amp;&amp;other) = delete;
     110: 
     111:   /**
</code></pre></div>
<p><strong>Violation 44</strong>: freertos_stream_buffer.hpp:112:23
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     109:       : m_stream_buffer{m_allocator.create(trigger_level_bytes)} {
     110:     configASSERT(m_stream_buffer);
     111:   }
&gt;&gt;&gt;  112:   stream_buffer(const stream_buffer &amp;) = delete;
     113:   stream_buffer(stream_buffer &amp;&amp;src) = delete;
     114:   /**
     115:    * @brief Destruct the stream buffer object and delete the stream buffer
</code></pre></div>
<p><strong>Violation 45</strong>: freertos_stream_buffer.hpp:125:34
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     122:     }
     123:   }
     124: 
&gt;&gt;&gt;  125:   stream_buffer &amp;operator=(const stream_buffer &amp;) = delete;
     126:   stream_buffer &amp;operator=(stream_buffer &amp;&amp;src) = delete;
     127: 
     128:   /**
</code></pre></div>
<h4 id="misra-c-2012-rule-85-6-violations">MISRA C 2012 Rule 8.5 (6 violation(s))</h4>
<p><strong>An external object or function shall be declared once in one and only one file</strong></p>
<p>External objects and functions should have exactly one declaration to avoid multiple definition errors and ensure consistent interfaces.</p>
<p><em>Rationale: Multiple declarations can lead to inconsistencies and linking errors.</em></p>
<p><strong>Violation 1</strong>: freertos_task.hpp:1069:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1066:  * @tparam Duration duration type
    1067:  * @param timePoint time point to sleep until
    1068:  */
&gt;&gt;&gt; 1069: void delay_until(const std::chrono::system_clock::time_point &amp;wakeTime);
    1070: /**
    1071:  * @brief Sleep the task until the specified time point.
    1072:  *
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_task.hpp:1052:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1049:  * @tparam Duration duration type
    1050:  * @param timePoint time point to sleep until
    1051:  */
&gt;&gt;&gt; 1052: void delay_until(TickType_t &amp;previousWakeTime, TickType_t period);
    1053: 
    1054: template &lt;typename Rep, typename Period&gt;
    1055: void delay_until(TickType_t &amp;previousWakeTime,
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_task.hpp:1077:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1074:  * @tparam Duration duration type
    1075:  * @param timePoint time point to sleep until
    1076:  */
&gt;&gt;&gt; 1077: void delay_until(const std::chrono::steady_clock::time_point &amp;wakeTime);
    1078: 
    1079: // task utilities:
    1080: 
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_task.hpp:1069:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1066:  * @tparam Duration duration type
    1067:  * @param timePoint time point to sleep until
    1068:  */
&gt;&gt;&gt; 1069: void delay_until(const std::chrono::system_clock::time_point &amp;wakeTime);
    1070: /**
    1071:  * @brief Sleep the task until the specified time point.
    1072:  *
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_task.hpp:1052:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1049:  * @tparam Duration duration type
    1050:  * @param timePoint time point to sleep until
    1051:  */
&gt;&gt;&gt; 1052: void delay_until(TickType_t &amp;previousWakeTime, TickType_t period);
    1053: 
    1054: template &lt;typename Rep, typename Period&gt;
    1055: void delay_until(TickType_t &amp;previousWakeTime,
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_task.hpp:1077:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1074:  * @tparam Duration duration type
    1075:  * @param timePoint time point to sleep until
    1076:  */
&gt;&gt;&gt; 1077: void delay_until(const std::chrono::steady_clock::time_point &amp;wakeTime);
    1078: 
    1079: // task utilities:
    1080: 
</code></pre></div>
<h4 id="misra-c-2012-rule-86-40-violations">MISRA C 2012 Rule 8.6 (40 violation(s))</h4>
<p><strong>An identifier with external linkage shall have exactly one external definition</strong></p>
<p>Each external identifier should be defined exactly once across the entire program to avoid multiple definition errors.</p>
<p><em>Rationale: Multiple definitions of the same external identifier violate the one definition rule and can cause linking errors.</em></p>
<p><strong>Violation 1</strong>: freertos_task.cc:37:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      34: 
      35: namespace freertos {
      36: 
&gt;&gt;&gt;   37: void delay(TickType_t ticks) { vTaskDelay(ticks); }
      38: void delay_until(TickType_t &amp;previousWakeTime, TickType_t period) {
      39:   vTaskDelayUntil(&amp;previousWakeTime, period);
      40: }
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_task.hpp:1028:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1025:  * @param duration duration to delay
    1026:  */
    1027: template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt; 1028: void delay(std::chrono::duration&lt;Rep, Period&gt; duration) {
    1029:   delay(
    1030:       std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count());
    1031: }
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_task.cc:38:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      35: namespace freertos {
      36: 
      37: void delay(TickType_t ticks) { vTaskDelay(ticks); }
&gt;&gt;&gt;   38: void delay_until(TickType_t &amp;previousWakeTime, TickType_t period) {
      39:   vTaskDelayUntil(&amp;previousWakeTime, period);
      40: }
      41: void delay_until(const std::chrono::system_clock::time_point &amp;wakeTime) {
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_task.hpp:1055:6
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1052: void delay_until(TickType_t &amp;previousWakeTime, TickType_t period);
    1053: 
    1054: template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt; 1055: void delay_until(TickType_t &amp;previousWakeTime,
    1056:                  std::chrono::duration&lt;Rep, Period&gt; period) {
    1057:   delay_until(
    1058:       previousWakeTime,
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_message_buffer.hpp:120:19
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     117:     }
     118:   }
     119: 
&gt;&gt;&gt;  120:   message_buffer &amp;operator=(const message_buffer &amp;) = delete;
     121:   message_buffer &amp;operator=(message_buffer &amp;&amp;src) = delete;
     122: 
     123:   /**
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_event_group.hpp:109:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     106:   }
     107: 
     108:   event_group &amp;operator=(const event_group &amp;) = delete;
&gt;&gt;&gt;  109:   event_group &amp;operator=(event_group &amp;&amp;other) = delete;
     110: 
     111:   /**
     112:    * @brief Method to get the handle of the event group.
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_queue.hpp:218:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     215:     }
     216:   }
     217: 
&gt;&gt;&gt;  218:   queue &amp;operator=(const queue &amp;) = delete;
     219:   queue &amp;operator=(queue &amp;&amp;src) = delete;
     220: 
     221:   /**
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_message_buffer.hpp:121:19
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     118:   }
     119: 
     120:   message_buffer &amp;operator=(const message_buffer &amp;) = delete;
&gt;&gt;&gt;  121:   message_buffer &amp;operator=(message_buffer &amp;&amp;src) = delete;
     122: 
     123:   /**
     124:    * @brief Method sends a discret message to the message buffer.
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_queue.hpp:231:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     228:    * @return BaseType_t pdPASS if the item was successfully posted, otherwise
     229:    * errQUEUE_FULL.
     230:    */
&gt;&gt;&gt;  231:   BaseType_t send(const T &amp;item, TickType_t ticks_to_wait) {
     232:     return xQueueSend(m_queue, &amp;item, ticks_to_wait);
     233:   }
     234:   /**
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_message_buffer.hpp:148:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     145:    * @return size_t number of bytes sent
     146:    */
     147:   template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt;  148:   size_t send(const void *pvTxData, size_t xDataLengthBytes,
     149:               const std::chrono::duration&lt;Rep, Period&gt; &amp;xTicksToWait) {
     150:     return send(
     151:         pvTxData, xDataLengthBytes,
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_queue.hpp:400:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     397:    * @return BaseType_t pdPASS if the item was successfully received, otherwise
     398:    * pdFALSE.
     399:    */
&gt;&gt;&gt;  400:   BaseType_t receive(T &amp;item, TickType_t ticks_to_wait) {
     401:     return xQueueReceive(m_queue, &amp;item, ticks_to_wait);
     402:   }
     403:   /**
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_message_buffer.hpp:181:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     178:    * @return size_t number of bytes received
     179:    */
     180:   template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt;  181:   size_t receive(void *pvRxData, size_t xBufferLengthBytes,
     182:                  const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     183:     return receive(
     184:         pvRxData, xBufferLengthBytes,
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_queue.hpp:520:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     517:    *
     518:    * @return BaseType_t pdPASS if the queue was reset, pdFAIL otherwise.
     519:    */
&gt;&gt;&gt;  520:   BaseType_t reset(void) { return xQueueReset(m_queue); }
     521:   /**
     522:    * @brief A version of send_back method that overwrites the items in the queue
     523:    * if it is full.
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_message_buffer.hpp:202:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     199:    *
     200:    * @return BaseType_t pdPass if the message buffer was reset, pdFAIL otherwise
     201:    */
&gt;&gt;&gt;  202:   BaseType_t reset(void) { return xMessageBufferReset(m_message_buffer); }
     203:   /**
     204:    * @brief Method checking if the message buffer is empty.
     205:    * @ref https://www.freertos.org/xMessageBufferIsEmpty.html
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_semaphore.hpp:190:21
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     187:     }
     188:   }
     189: 
&gt;&gt;&gt;  190:   binary_semaphore &amp;operator=(const binary_semaphore &amp;) = delete;
     191:   binary_semaphore &amp;operator=(binary_semaphore &amp;&amp;src) = delete;
     192: 
     193:   /**
</code></pre></div>
<p><strong>Violation 16</strong>: freertos_queue.hpp:219:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     216:   }
     217: 
     218:   queue &amp;operator=(const queue &amp;) = delete;
&gt;&gt;&gt;  219:   queue &amp;operator=(queue &amp;&amp;src) = delete;
     220: 
     221:   /**
     222:    * @brief Posts an item to the back of a queue.
</code></pre></div>
<p><strong>Violation 17</strong>: freertos_stream_buffer.hpp:125:18
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     122:     }
     123:   }
     124: 
&gt;&gt;&gt;  125:   stream_buffer &amp;operator=(const stream_buffer &amp;) = delete;
     126:   stream_buffer &amp;operator=(stream_buffer &amp;&amp;src) = delete;
     127: 
     128:   /**
</code></pre></div>
<p><strong>Violation 18</strong>: freertos_semaphore.hpp:950:23
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     947:   timeout_lock_guard(const timeout_lock_guard &amp;) = delete;
     948:   timeout_lock_guard(timeout_lock_guard &amp;&amp;) = delete;
     949:   timeout_lock_guard &amp;operator=(const timeout_lock_guard &amp;) = delete;
&gt;&gt;&gt;  950:   timeout_lock_guard &amp;operator=(timeout_lock_guard &amp;&amp;) = delete;
     951: 
     952:   /**
     953:    * @brief Checks if the mutex is locked.
</code></pre></div>
<p><strong>Violation 19</strong>: freertos_stream_buffer.hpp:140:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     137:    * stream buffer, otherwise errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY if there was
     138:    * insufficient memory available to copy the data into the stream buffer.
     139:    */
&gt;&gt;&gt;  140:   BaseType_t send(const void *data, size_t data_size,
     141:                   TickType_t timeout = portMAX_DELAY) {
     142:     return xStreamBufferSend(m_stream_buffer, data, data_size, timeout);
     143:   }
</code></pre></div>
<p><strong>Violation 20</strong>: freertos_queue.hpp:244:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     241:    * errQUEUE_FULL.
     242:    */
     243:   template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt;  244:   BaseType_t send(const T &amp;item,
     245:                   const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     246:     return send(
     247:         item, pdMS_TO_TICKS(
</code></pre></div>
<p><strong>Violation 21</strong>: freertos_stream_buffer.hpp:212:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     209:    * stream buffer, otherwise errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY if there was
     210:    * insufficient memory available to copy the data into the stream buffer.
     211:    */
&gt;&gt;&gt;  212:   BaseType_t send_isr(const void *data, size_t data_size,
     213:                       BaseType_t &amp;higher_priority_task_woken) {
     214:     return xStreamBufferSendFromISR(m_stream_buffer, data, data_size,
     215:                                     &amp;higher_priority_task_woken);
</code></pre></div>
<p><strong>Violation 22</strong>: freertos_queue.hpp:272:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     269:    * @return BaseType_t  pdPASS if the item was successfully posted, otherwise
     270:    * errQUEUE_FULL.
     271:    */
&gt;&gt;&gt;  272:   BaseType_t send_isr(const T &amp;item) {
     273:     BaseType_t higher_priority_task_woken = pdFALSE;
     274:     return xQueueSendFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     275:   }
</code></pre></div>
<p><strong>Violation 23</strong>: freertos_stream_buffer.hpp:280:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     277:    * buffer.
     278:    * @return size_t Number of bytes received.
     279:    */
&gt;&gt;&gt;  280:   size_t receive(void *data, size_t data_size,
     281:                  TickType_t timeout = portMAX_DELAY) {
     282:     return xStreamBufferReceive(m_stream_buffer, data, data_size, timeout);
     283:   }
</code></pre></div>
<p><strong>Violation 24</strong>: freertos_queue.hpp:444:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     441:    * queue is empty.
     442:    */
     443:   template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt;  444:   optional&lt;T&gt; receive(const std::chrono::duration&lt;Rep, Period&gt; &amp;timeout) {
     445:     return receive(pdMS_TO_TICKS(
     446:         std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(timeout)
     447:             .count()));
</code></pre></div>
<p><strong>Violation 25</strong>: freertos_stream_buffer.hpp:313:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     310:    * data from the stream buffer, otherwise it will be set to pdFALSE.
     311:    * @return size_t Number of bytes received.
     312:    */
&gt;&gt;&gt;  313:   size_t receive_isr(void *data, size_t data_size,
     314:                      BaseType_t &amp;higher_priority_task_woken) {
     315:     return xStreamBufferReceiveFromISR(m_stream_buffer, data, data_size,
     316:                                        &amp;higher_priority_task_woken);
</code></pre></div>
<p><strong>Violation 26</strong>: freertos_queue.hpp:482:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     479:    * @return optional&lt;T&gt; The item received from the queue or std::nullopt if the
     480:    * queue is empty.
     481:    */
&gt;&gt;&gt;  482:   optional&lt;T&gt; receive_isr(void) {
     483:     T item;
     484:     BaseType_t higher_priority_task_woken = pdFALSE;
     485:     if (xQueueReceiveFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken) ==
</code></pre></div>
<p><strong>Violation 27</strong>: freertos_stream_buffer.hpp:337:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     334:    *
     335:    * @return size_t Number of bytes available in the stream buffer.
     336:    */
&gt;&gt;&gt;  337:   size_t available(void) {
     338:     return xStreamBufferBytesAvailable(m_stream_buffer);
     339:   }
     340:   /**
</code></pre></div>
<p><strong>Violation 28</strong>: freertos_message_buffer.hpp:193:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     190:    *
     191:    * @return size_t the number of bytes available in the buffer
     192:    */
&gt;&gt;&gt;  193:   size_t available(void) const {
     194:     return xMessageBufferSpaceAvailable(m_message_buffer);
     195:   }
     196:   /**
</code></pre></div>
<p><strong>Violation 29</strong>: freertos_stream_buffer.hpp:353:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     350:    *
     351:    * @return BaseType_t pdPass if the stream buffer was reset, pdFAIL otherwise.
     352:    */
&gt;&gt;&gt;  353:   BaseType_t reset(void) { return xStreamBufferReset(m_stream_buffer); }
     354:   /**
     355:    * @brief Set the trigger level of the stream buffer.
     356:    * @ref https://www.freertos.org/xStreamBufferSetTriggerLevel.html
</code></pre></div>
<p><strong>Violation 30</strong>: freertos_stream_buffer.hpp:370:24
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     367:    *
     368:    * @return StreamBufferHandle_t Handle of the stream buffer.
     369:    */
&gt;&gt;&gt;  370:   StreamBufferHandle_t handle(void) const { return m_stream_buffer; }
     371:   /**
     372:    * @brief Check if the stream buffer is empty.
     373:    * @ref https://www.freertos.org/xStreamBufferIsEmpty.html
</code></pre></div>
<p><strong>Violation 31</strong>: freertos_event_group.hpp:117:22
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     114:    *
     115:    * @return EventGroupHandle_t event group handle
     116:    */
&gt;&gt;&gt;  117:   EventGroupHandle_t handle(void) const { return m_event_group; }
     118: 
     119:   /**
     120:    * @brief Method to set bits in the event group.
</code></pre></div>
<p><strong>Violation 32</strong>: freertos_stream_buffer.hpp:377:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     374:    *
     375:    * @return BaseType_t pdTRUE if the stream buffer is empty, pdFALSE otherwise.
     376:    */
&gt;&gt;&gt;  377:   BaseType_t empty(void) { return xStreamBufferIsEmpty(m_stream_buffer); }
     378:   /**
     379:    * @brief Check if the stream buffer is full.
     380:    * @ref https://www.freertos.org/xStreamBufferIsFull.html
</code></pre></div>
<p><strong>Violation 33</strong>: freertos_message_buffer.hpp:209:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     206:    *
     207:    * @return BaseType_t pdTRUE if the message buffer is empty, pdFALSE otherwise
     208:    */
&gt;&gt;&gt;  209:   BaseType_t empty(void) { return xMessageBufferIsEmpty(m_message_buffer); }
     210:   /**
     211:    * @brief Method checking if the message buffer is full.
     212:    * @ref https://www.freertos.org/xMessageBufferIsFull.html
</code></pre></div>
<p><strong>Violation 34</strong>: freertos_stream_buffer.hpp:384:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     381:    *
     382:    * @return BaseType_t pdTRUE if the stream buffer is full, pdFALSE otherwise.
     383:    */
&gt;&gt;&gt;  384:   BaseType_t full(void) { return xStreamBufferIsFull(m_stream_buffer); }
     385: };
     386: 
     387: #if configSUPPORT_STATIC_ALLOCATION
</code></pre></div>
<p><strong>Violation 35</strong>: freertos_message_buffer.hpp:216:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     213:    *
     214:    * @return BaseType_t pdTRUE if the message buffer is full, pdFALSE otherwise
     215:    */
&gt;&gt;&gt;  216:   BaseType_t full(void) { return xMessageBufferIsFull(m_message_buffer); }
     217: };
     218: 
     219: #if configSUPPORT_STATIC_ALLOCATION
</code></pre></div>
<p><strong>Violation 36</strong>: freertos_task.hpp:1214:21
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">    1211:   // Delete copy and move operations for RAII safety
    1212:   critical_section(const critical_section &amp;) = delete;
    1213:   critical_section(critical_section &amp;&amp;) = delete;
&gt;&gt;&gt; 1214:   critical_section &amp;operator=(const critical_section &amp;) = delete;
    1215:   critical_section &amp;operator=(critical_section &amp;&amp;) = delete;
    1216: };
    1217: 
</code></pre></div>
<p><strong>Violation 37</strong>: freertos_stream_buffer.hpp:126:18
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     123:   }
     124: 
     125:   stream_buffer &amp;operator=(const stream_buffer &amp;) = delete;
&gt;&gt;&gt;  126:   stream_buffer &amp;operator=(stream_buffer &amp;&amp;src) = delete;
     127: 
     128:   /**
     129:    * @brief Send data to the stream buffer.
</code></pre></div>
<p><strong>Violation 38</strong>: freertos_task.hpp:267:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     264:    *
     265:    * @return TaskHandle_t task handle
     266:    */
&gt;&gt;&gt;  267:   TaskHandle_t handle(void) const { return m_hTask; }
     268: #if INCLUDE_vTaskSuspend
     269:   /**
     270:    * @brief Suspend the task.
</code></pre></div>
<p><strong>Violation 39</strong>: freertos_task.hpp:421:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     418:    *
     419:    * @return const char* task name
     420:    */
&gt;&gt;&gt;  421:   const char *name(void) const { return pcTaskGetName(m_hTask); }
     422: // Task notification API
     423: #if configUSE_TASK_NOTIFICATIONS
     424:   /**
</code></pre></div>
<p><strong>Violation 40</strong>: freertos_queue.hpp:668:15
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     665:    *
     666:    * @return const char* The name of the queue.
     667:    */
&gt;&gt;&gt;  668:   const char *name(void) const { return pcQueueGetName(m_queue); }
     669:   /**
     670:    * @brief Method checking if the queue is full from an ISR.
     671:    * @ref https://www.freertos.org/a00018.html#xQueueIsQueueFullFromISR
</code></pre></div>
<h4 id="misra-c-2012-rule-87-15-violations">MISRA C 2012 Rule 8.7 (15 violation(s))</h4>
<p><strong>Functions and objects should not be defined with external linkage if they are referenced from only one translation unit</strong></p>
<p>Functions and objects used only within a single file should be declared static to limit their scope and avoid namespace pollution.</p>
<p><em>Rationale: Internal linkage prevents namespace pollution and allows for better optimization by the compiler.</em></p>
<p><strong>Violation 1</strong>: freertos_task.hpp:728:8
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     725:    *
     726:    * @return bool true if the task is running, false otherwise
     727:    */
&gt;&gt;&gt;  728:   bool is_running(void) const {
     729:     switch (m_task.state()) {
     730:     case eRunning:
     731:     case eReady:
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_task.hpp:704:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     701:    *
     702:    * @return TaskHandle_t task handle
     703:    */
&gt;&gt;&gt;  704:   TaskHandle_t handle(void) const { return m_task.handle(); }
     705: #if INCLUDE_vTaskSuspend
     706:   /**
     707:    * @brief Suspend the task.
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_task.hpp:743:8
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     740:    * @brief Terminate the task.
     741:    *
     742:    */
&gt;&gt;&gt;  743:   void terminate(void) { m_task.terminate(); }
     744: #if INCLUDE_xTaskAbortDelay
     745:   /**
     746:    * @brief Abort the delay of the task.
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_task.cc:59:12
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      56: #if INCLUDE_xTaskGetIdleTaskHandle
      57: TaskHandle_t idle_task_handle(void) { return xTaskGetIdleTaskHandle(); }
      58: #endif
&gt;&gt;&gt;   59: TickType_t tick_count(void) { return xTaskGetTickCount(); }
      60: TickType_t tick_count_isr(void) { return xTaskGetTickCountFromISR(); }
      61: std::chrono::milliseconds time_since_scheduler_started(void) {
      62:   return std::chrono::milliseconds{tick_count() * portTICK_PERIOD_MS};
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_task.cc:60:12
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">      57: TaskHandle_t idle_task_handle(void) { return xTaskGetIdleTaskHandle(); }
      58: #endif
      59: TickType_t tick_count(void) { return xTaskGetTickCount(); }
&gt;&gt;&gt;   60: TickType_t tick_count_isr(void) { return xTaskGetTickCountFromISR(); }
      61: std::chrono::milliseconds time_since_scheduler_started(void) {
      62:   return std::chrono::milliseconds{tick_count() * portTICK_PERIOD_MS};
      63: }
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_stream_buffer.hpp:264:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     261:    * insufficient memory available to copy the data into the stream buffer.
     262:    */
     263:   template &lt;typename Iterator&gt;
&gt;&gt;&gt;  264:   BaseType_t send_isr(Iterator begin, Iterator end) {
     265:     BaseType_t higher_priority_task_woken = pdFALSE;
     266:     return send_isr(&amp;*begin, std::distance(begin, end),
     267:                     higher_priority_task_woken);
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_stream_buffer.hpp:327:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     324:    * @param data_size Maximum number of bytes to copy into the buffer.
     325:    * @return size_t Number of bytes received.
     326:    */
&gt;&gt;&gt;  327:   size_t receive_isr(void *data, size_t data_size) {
     328:     BaseType_t higher_priority_task_woken = pdFALSE;
     329:     return receive_isr(data, data_size, higher_priority_task_woken);
     330:   }
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_task.hpp:728:8
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     725:    *
     726:    * @return bool true if the task is running, false otherwise
     727:    */
&gt;&gt;&gt;  728:   bool is_running(void) const {
     729:     switch (m_task.state()) {
     730:     case eRunning:
     731:     case eReady:
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_task.hpp:704:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     701:    *
     702:    * @return TaskHandle_t task handle
     703:    */
&gt;&gt;&gt;  704:   TaskHandle_t handle(void) const { return m_task.handle(); }
     705: #if INCLUDE_vTaskSuspend
     706:   /**
     707:    * @brief Suspend the task.
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_task.hpp:743:8
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     740:    * @brief Terminate the task.
     741:    *
     742:    */
&gt;&gt;&gt;  743:   void terminate(void) { m_task.terminate(); }
     744: #if INCLUDE_xTaskAbortDelay
     745:   /**
     746:    * @brief Abort the delay of the task.
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_task.hpp:728:8
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     725:    *
     726:    * @return bool true if the task is running, false otherwise
     727:    */
&gt;&gt;&gt;  728:   bool is_running(void) const {
     729:     switch (m_task.state()) {
     730:     case eRunning:
     731:     case eReady:
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_task.hpp:704:16
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     701:    *
     702:    * @return TaskHandle_t task handle
     703:    */
&gt;&gt;&gt;  704:   TaskHandle_t handle(void) const { return m_task.handle(); }
     705: #if INCLUDE_vTaskSuspend
     706:   /**
     707:    * @brief Suspend the task.
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_task.hpp:743:8
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     740:    * @brief Terminate the task.
     741:    *
     742:    */
&gt;&gt;&gt;  743:   void terminate(void) { m_task.terminate(); }
     744: #if INCLUDE_xTaskAbortDelay
     745:   /**
     746:    * @brief Abort the delay of the task.
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_stream_buffer.hpp:264:14
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     261:    * insufficient memory available to copy the data into the stream buffer.
     262:    */
     263:   template &lt;typename Iterator&gt;
&gt;&gt;&gt;  264:   BaseType_t send_isr(Iterator begin, Iterator end) {
     265:     BaseType_t higher_priority_task_woken = pdFALSE;
     266:     return send_isr(&amp;*begin, std::distance(begin, end),
     267:                     higher_priority_task_woken);
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_stream_buffer.hpp:327:10
<em>Reason: Coding Style</em></p>
<pre><code class="language-cpp">     324:    * @param data_size Maximum number of bytes to copy into the buffer.
     325:    * @return size_t Number of bytes received.
     326:    */
&gt;&gt;&gt;  327:   size_t receive_isr(void *data, size_t data_size) {
     328:     BaseType_t higher_priority_task_woken = pdFALSE;
     329:     return receive_isr(data, data_size, higher_priority_task_woken);
     330:   }
</code></pre></div>
<h3 id="analysis-errors">Analysis Errors</h3>
<p>Some files could not be fully analyzed:</p>
<div class="code-block"><pre><code>/home/runner/work/freertos_cpp_wrappers/freertos_cpp_wrappers/src/freertos_task.cc:0:0: error: Bailing out from analysis: Checking file failed: Failed to execute addon 'misra' - exitcode is 1 [internalError]
/home/runner/work/freertos_cpp_wrappers/freertos_cpp_wrappers/include/freertos.hpp:0:0: error: Bailing out from analysis: Checking file failed: Failed to execute addon 'misra' - exitcode is 1 [internalError]
/home/runner/work/freertos_cpp_wrappers/freertos_cpp_wrappers/include/freertos_task.hpp:0:0: error: Bailing out from analysis: Checking file failed: Failed to execute addon 'misra' - exitcode is 1 [internalError]
</code></pre></div>
<h3 id="analysis-notes">Analysis Notes</h3>
<ul>
<li><strong>Standard</strong>: MISRA C 2012 (applicable rules for C++)</li>
<li><strong>Tool</strong>: cppcheck with MISRA addon</li>
<li><strong>Scope</strong>: Library modules only (src/, include/)</li>
<li><strong>Rule texts</strong>: Cannot be displayed due to MISRA licensing restrictions</li>
<li><strong>Compatibility</strong>: Many MISRA C 2012 rules overlap with MISRA C++ 2008 requirements</li>
<li><strong>Integration</strong>: This analysis complements the existing clang-tidy static analysis</li>
</ul>
</div><div class="section"><h2 id="enhanced-cppcheck-analysis-all-rules">Enhanced cppcheck Analysis (All Rules)</h2>
<h3 id="summary_2">Summary</h3>
<ul>
<li><strong>Total Violations</strong>: 100</li>
<li><strong>Unique Rules Violated</strong>: 4</li>
<li><strong>Files Analyzed</strong>: 9</li>
<li><strong>Analysis Errors</strong>: 3</li>
</ul>
<h3 id="violations-by-severity_1">Violations by Severity</h3>
<ul>
<li><strong>Style</strong>: 94</li>
<li><strong>Warning</strong>: 6</li>
</ul>
<h3 id="violations-by-category">Violations by Category</h3>
<ul>
<li><strong>Unused Code</strong>: 84 violation(s)</li>
<li><strong>Other</strong>: 10 violation(s)</li>
<li><strong>Const Correctness</strong>: 6 violation(s)</li>
</ul>
<h3 id="violations-by-rule_1">Violations by Rule</h3>
<ul>
<li><strong>constParameterReference</strong> (Const Correctness): 6 violation(s)</li>
<li><strong>shadowFunction</strong> (Other): 4 violation(s)</li>
<li><strong>uninitMemberVar</strong> (Other): 6 violation(s)</li>
<li><strong>unusedFunction</strong> (Unused Code): 84 violation(s)</li>
</ul>
<h3 id="violations-by-file_1">Violations by File</h3>
<ul>
<li><strong>freertos_event_group.hpp</strong>: 11 violation(s)</li>
<li><strong>freertos_message_buffer.hpp</strong>: 9 violation(s)</li>
<li><strong>freertos_queue.hpp</strong>: 26 violation(s)</li>
<li><strong>freertos_semaphore.hpp</strong>: 8 violation(s)</li>
<li><strong>freertos_stream_buffer.hpp</strong>: 11 violation(s)</li>
<li><strong>freertos_sw_timer.hpp</strong>: 11 violation(s)</li>
<li><strong>freertos_task.cc</strong>: 6 violation(s)</li>
<li><strong>freertos_task.hpp</strong>: 18 violation(s)</li>
</ul>
<h3 id="detailed-violations-with-code-context_1">Detailed Violations with Code Context</h3>
<h4 id="const-correctness-6-violations">Const Correctness (6 violation(s))</h4>
<h5 id="constparameterreference">constParameterReference</h5>
<p><strong>Violation 1</strong>: freertos_task.hpp:914:37
<em>Style</em>: Parameter 'higherPriorityTaskWoken' can be declared as reference to const</p>
<pre><code class="language-cpp">     911:    * @return BaseType_t  pdTRUE if the notification was given, pdFALSE otherwise
     912:    */
     913:   BaseType_t notify_isr(const uint32_t val, eNotifyAction action,
&gt;&gt;&gt;  914:                         BaseType_t &amp;higherPriorityTaskWoken) {
     915:     return m_task.notify_isr(val, action, higherPriorityTaskWoken);
     916:   }
     917:   /**
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_task.hpp:939:47
<em>Style</em>: Parameter 'higherPriorityTaskWoken' can be declared as reference to const</p>
<pre><code class="language-cpp">     936:    */
     937:   BaseType_t notify_and_query_isr(const uint32_t val, eNotifyAction action,
     938:                                   uint32_t &amp;prev_value,
&gt;&gt;&gt;  939:                                   BaseType_t &amp;higherPriorityTaskWoken) {
     940:     return m_task.notify_and_query_isr(val, action, prev_value,
     941:                                        higherPriorityTaskWoken);
     942:   }
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_task.hpp:914:37
<em>Style</em>: Parameter 'higherPriorityTaskWoken' can be declared as reference to const</p>
<pre><code class="language-cpp">     911:    * @return BaseType_t  pdTRUE if the notification was given, pdFALSE otherwise
     912:    */
     913:   BaseType_t notify_isr(const uint32_t val, eNotifyAction action,
&gt;&gt;&gt;  914:                         BaseType_t &amp;higherPriorityTaskWoken) {
     915:     return m_task.notify_isr(val, action, higherPriorityTaskWoken);
     916:   }
     917:   /**
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_task.hpp:939:47
<em>Style</em>: Parameter 'higherPriorityTaskWoken' can be declared as reference to const</p>
<pre><code class="language-cpp">     936:    */
     937:   BaseType_t notify_and_query_isr(const uint32_t val, eNotifyAction action,
     938:                                   uint32_t &amp;prev_value,
&gt;&gt;&gt;  939:                                   BaseType_t &amp;higherPriorityTaskWoken) {
     940:     return m_task.notify_and_query_isr(val, action, prev_value,
     941:                                        higherPriorityTaskWoken);
     942:   }
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_task.hpp:914:37
<em>Style</em>: Parameter 'higherPriorityTaskWoken' can be declared as reference to const</p>
<pre><code class="language-cpp">     911:    * @return BaseType_t  pdTRUE if the notification was given, pdFALSE otherwise
     912:    */
     913:   BaseType_t notify_isr(const uint32_t val, eNotifyAction action,
&gt;&gt;&gt;  914:                         BaseType_t &amp;higherPriorityTaskWoken) {
     915:     return m_task.notify_isr(val, action, higherPriorityTaskWoken);
     916:   }
     917:   /**
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_task.hpp:939:47
<em>Style</em>: Parameter 'higherPriorityTaskWoken' can be declared as reference to const</p>
<pre><code class="language-cpp">     936:    */
     937:   BaseType_t notify_and_query_isr(const uint32_t val, eNotifyAction action,
     938:                                   uint32_t &amp;prev_value,
&gt;&gt;&gt;  939:                                   BaseType_t &amp;higherPriorityTaskWoken) {
     940:     return m_task.notify_and_query_isr(val, action, prev_value,
     941:                                        higherPriorityTaskWoken);
     942:   }
</code></pre></div>
<h4 id="other-10-violations">Other (10 violation(s))</h4>
<h5 id="shadowfunction">shadowFunction</h5>
<p><strong>Violation 1</strong>: freertos_sw_timer.hpp:202:14
<em>Style</em>: Local variable 'name' shadows outer function</p>
<pre><code class="language-cpp">     199:         while (xTimerIsTimerActive(src.m_timer) != pdFALSE) {
     200:           vTaskDelay(pdMS_TO_TICKS(1));
     201:         }
&gt;&gt;&gt;  202:         auto name = pcTimerGetName(src.m_timer);
     203:         auto period = xTimerGetPeriod(src.m_timer);
     204:         auto auto_reload = uxTimerGetReloadMode(src.m_timer);
     205:         rc = xTimerDelete(src.m_timer, portMAX_DELAY);
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_sw_timer.hpp:203:14
<em>Style</em>: Local variable 'period' shadows outer function</p>
<pre><code class="language-cpp">     200:           vTaskDelay(pdMS_TO_TICKS(1));
     201:         }
     202:         auto name = pcTimerGetName(src.m_timer);
&gt;&gt;&gt;  203:         auto period = xTimerGetPeriod(src.m_timer);
     204:         auto auto_reload = uxTimerGetReloadMode(src.m_timer);
     205:         rc = xTimerDelete(src.m_timer, portMAX_DELAY);
     206:         if (rc == pdPASS) {
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_sw_timer.hpp:202:14
<em>Style</em>: Local variable 'name' shadows outer function</p>
<pre><code class="language-cpp">     199:         while (xTimerIsTimerActive(src.m_timer) != pdFALSE) {
     200:           vTaskDelay(pdMS_TO_TICKS(1));
     201:         }
&gt;&gt;&gt;  202:         auto name = pcTimerGetName(src.m_timer);
     203:         auto period = xTimerGetPeriod(src.m_timer);
     204:         auto auto_reload = uxTimerGetReloadMode(src.m_timer);
     205:         rc = xTimerDelete(src.m_timer, portMAX_DELAY);
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_sw_timer.hpp:203:14
<em>Style</em>: Local variable 'period' shadows outer function</p>
<pre><code class="language-cpp">     200:           vTaskDelay(pdMS_TO_TICKS(1));
     201:         }
     202:         auto name = pcTimerGetName(src.m_timer);
&gt;&gt;&gt;  203:         auto period = xTimerGetPeriod(src.m_timer);
     204:         auto auto_reload = uxTimerGetReloadMode(src.m_timer);
     205:         rc = xTimerDelete(src.m_timer, portMAX_DELAY);
     206:         if (rc == pdPASS) {
</code></pre></div>
<h5 id="uninitmembervar">uninitMemberVar</h5>
<p><strong>Violation 1</strong>: freertos_message_buffer.hpp:57:3
<em>Warning</em>: Member variable 'static_message_buffer_allocator::m_storage' is not initialized in the constructor.</p>
<pre><code class="language-cpp">      54:   std::array&lt;uint8_t, MessageBufferSize&gt; m_storage;
      55: 
      56: public:
&gt;&gt;&gt;   57:   static_message_buffer_allocator() = default;
      58:   ~static_message_buffer_allocator() = default;
      59:   static_message_buffer_allocator(const static_message_buffer_allocator &amp;) =
      60:       delete;
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_queue.hpp:59:3
<em>Warning</em>: Member variable 'static_queue_allocator::m_storage' is not initialized in the constructor.</p>
<pre><code class="language-cpp">      56:   std::array&lt;uint8_t, QueueLength * sizeof(T)&gt; m_storage;
      57: 
      58: public:
&gt;&gt;&gt;   59:   static_queue_allocator() = default;
      60:   ~static_queue_allocator() = default;
      61:   static_queue_allocator(const static_queue_allocator &amp;) = delete;
      62:   static_queue_allocator(static_queue_allocator &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_stream_buffer.hpp:58:3
<em>Warning</em>: Member variable 'static_stream_buffer_allocator::m_storage' is not initialized in the constructor.</p>
<pre><code class="language-cpp">      55:   std::array&lt;uint8_t, StreamBufferSize&gt; m_storage;
      56: 
      57: public:
&gt;&gt;&gt;   58:   static_stream_buffer_allocator() = default;
      59:   ~static_stream_buffer_allocator() = default;
      60:   static_stream_buffer_allocator(const static_stream_buffer_allocator &amp;) =
      61:       delete;
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_message_buffer.hpp:57:3
<em>Warning</em>: Member variable 'static_message_buffer_allocator::m_storage' is not initialized in the constructor.</p>
<pre><code class="language-cpp">      54:   std::array&lt;uint8_t, MessageBufferSize&gt; m_storage;
      55: 
      56: public:
&gt;&gt;&gt;   57:   static_message_buffer_allocator() = default;
      58:   ~static_message_buffer_allocator() = default;
      59:   static_message_buffer_allocator(const static_message_buffer_allocator &amp;) =
      60:       delete;
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_queue.hpp:59:3
<em>Warning</em>: Member variable 'static_queue_allocator::m_storage' is not initialized in the constructor.</p>
<pre><code class="language-cpp">      56:   std::array&lt;uint8_t, QueueLength * sizeof(T)&gt; m_storage;
      57: 
      58: public:
&gt;&gt;&gt;   59:   static_queue_allocator() = default;
      60:   ~static_queue_allocator() = default;
      61:   static_queue_allocator(const static_queue_allocator &amp;) = delete;
      62:   static_queue_allocator(static_queue_allocator &amp;&amp;) = delete;
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_stream_buffer.hpp:58:3
<em>Warning</em>: Member variable 'static_stream_buffer_allocator::m_storage' is not initialized in the constructor.</p>
<pre><code class="language-cpp">      55:   std::array&lt;uint8_t, StreamBufferSize&gt; m_storage;
      56: 
      57: public:
&gt;&gt;&gt;   58:   static_stream_buffer_allocator() = default;
      59:   ~static_stream_buffer_allocator() = default;
      60:   static_stream_buffer_allocator(const static_stream_buffer_allocator &amp;) =
      61:       delete;
</code></pre></div>
<h4 id="unused-code-84-violations">Unused Code (84 violation(s))</h4>
<h5 id="unusedfunction">unusedFunction</h5>
<p><strong>Violation 1</strong>: freertos_task.hpp:1041:0
<em>Style</em>: The function 'sleep_for' is never used.</p>
<pre><code class="language-cpp">    1038:  * @param duration duration to sleep
    1039:  */
    1040: template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt; 1041: void sleep_for(std::chrono::duration&lt;Rep, Period&gt; duration) {
    1042:   delay(duration);
    1043: }
    1044: 
</code></pre></div>
<p><strong>Violation 2</strong>: freertos_task.hpp:1108:0
<em>Style</em>: The function 'total_run_time' is never used.</p>
<pre><code class="language-cpp">    1105:    * @return UBaseType_t number of tasks
    1106:    */
    1107:   UBaseType_t count(void) const { return m_task_count; }
&gt;&gt;&gt; 1108:   std::chrono::milliseconds total_run_time(void) const {
    1109:     return std::chrono::milliseconds{m_total_run_time};
    1110:   }
    1111:   /**
</code></pre></div>
<p><strong>Violation 3</strong>: freertos_task.hpp:1116:0
<em>Style</em>: The function 'begin' is never used.</p>
<pre><code class="language-cpp">    1113:    *
    1114:    * @return const TaskStatus_t* begin iterator
    1115:    */
&gt;&gt;&gt; 1116:   const TaskStatus_t *begin(void) const { return m_status_array.data(); }
    1117:   /**
    1118:    * @brief Return the end iterator of the task status array.
    1119:    *
</code></pre></div>
<p><strong>Violation 4</strong>: freertos_task.hpp:1122:0
<em>Style</em>: The function 'end' is never used.</p>
<pre><code class="language-cpp">    1119:    *
    1120:    * @return const TaskStatus_t* end iterator
    1121:    */
&gt;&gt;&gt; 1122:   const TaskStatus_t *end(void) const {
    1123:     return m_status_array.data() + m_task_count;
    1124:   }
    1125: };
</code></pre></div>
<p><strong>Violation 5</strong>: freertos_task.cc:54:0
<em>Style</em>: The function 'current_task_handle' is never used.</p>
<pre><code class="language-cpp">      51:   }
      52: }
      53: #if INCLUDE_xTaskGetCurrentTaskHandle
&gt;&gt;&gt;   54: TaskHandle_t current_task_handle(void) { return xTaskGetCurrentTaskHandle(); }
      55: #endif
      56: #if INCLUDE_xTaskGetIdleTaskHandle
      57: TaskHandle_t idle_task_handle(void) { return xTaskGetIdleTaskHandle(); }
</code></pre></div>
<p><strong>Violation 6</strong>: freertos_task.cc:57:0
<em>Style</em>: The function 'idle_task_handle' is never used.</p>
<pre><code class="language-cpp">      54: TaskHandle_t current_task_handle(void) { return xTaskGetCurrentTaskHandle(); }
      55: #endif
      56: #if INCLUDE_xTaskGetIdleTaskHandle
&gt;&gt;&gt;   57: TaskHandle_t idle_task_handle(void) { return xTaskGetIdleTaskHandle(); }
      58: #endif
      59: TickType_t tick_count(void) { return xTaskGetTickCount(); }
      60: TickType_t tick_count_isr(void) { return xTaskGetTickCountFromISR(); }
</code></pre></div>
<p><strong>Violation 7</strong>: freertos_task.cc:61:0
<em>Style</em>: The function 'time_since_scheduler_started' is never used.</p>
<pre><code class="language-cpp">      58: #endif
      59: TickType_t tick_count(void) { return xTaskGetTickCount(); }
      60: TickType_t tick_count_isr(void) { return xTaskGetTickCountFromISR(); }
&gt;&gt;&gt;   61: std::chrono::milliseconds time_since_scheduler_started(void) {
      62:   return std::chrono::milliseconds{tick_count() * portTICK_PERIOD_MS};
      63: }
      64: std::chrono::milliseconds time_since_scheduler_started_isr(void) {
</code></pre></div>
<p><strong>Violation 8</strong>: freertos_task.cc:64:0
<em>Style</em>: The function 'time_since_scheduler_started_isr' is never used.</p>
<pre><code class="language-cpp">      61: std::chrono::milliseconds time_since_scheduler_started(void) {
      62:   return std::chrono::milliseconds{tick_count() * portTICK_PERIOD_MS};
      63: }
&gt;&gt;&gt;   64: std::chrono::milliseconds time_since_scheduler_started_isr(void) {
      65:   return std::chrono::milliseconds{tick_count_isr() * portTICK_PERIOD_MS};
      66: }
      67: #if INCLUDE_xTaskGetSchedulerState || configUSE_TIMERS
</code></pre></div>
<p><strong>Violation 9</strong>: freertos_task.cc:70:0
<em>Style</em>: The function 'task_count' is never used.</p>
<pre><code class="language-cpp">      67: #if INCLUDE_xTaskGetSchedulerState || configUSE_TIMERS
      68: BaseType_t get_scheduler_state(void) { return xTaskGetSchedulerState(); }
      69: #endif
&gt;&gt;&gt;   70: UBaseType_t task_count(void) { return uxTaskGetNumberOfTasks(); }
      71: void yield(void) { taskYIELD(); }
      72: 
      73: } // namespace freertos
</code></pre></div>
<p><strong>Violation 10</strong>: freertos_task.cc:71:0
<em>Style</em>: The function 'yield' is never used.</p>
<pre><code class="language-cpp">      68: BaseType_t get_scheduler_state(void) { return xTaskGetSchedulerState(); }
      69: #endif
      70: UBaseType_t task_count(void) { return uxTaskGetNumberOfTasks(); }
&gt;&gt;&gt;   71: void yield(void) { taskYIELD(); }
      72: 
      73: } // namespace freertos
</code></pre></div>
<p><strong>Violation 11</strong>: freertos_event_group.hpp:126:0
<em>Style</em>: The function 'set_bits' is never used.</p>
<pre><code class="language-cpp">     123:    * @param bits_to_set bits to set
     124:    * @return EventBits_t bits set
     125:    */
&gt;&gt;&gt;  126:   EventBits_t set_bits(const EventBits_t bits_to_set) {
     127:     return xEventGroupSetBits(m_event_group, bits_to_set);
     128:   }
     129:   /**
</code></pre></div>
<p><strong>Violation 12</strong>: freertos_event_group.hpp:136:0
<em>Style</em>: The function 'set_bits_isr' is never used.</p>
<pre><code class="language-cpp">     133:    * @param bits_to_set bits to set
     134:    * @return EventBits_t bits set
     135:    */
&gt;&gt;&gt;  136:   EventBits_t set_bits_isr(const EventBits_t bits_to_set) {
     137:     BaseType_t higher_priority_task_woken = pdFALSE;
     138:     const EventBits_t bits_set = xEventGroupSetBitsFromISR(
     139:         m_event_group, bits_to_set, &amp;higher_priority_task_woken);
</code></pre></div>
<p><strong>Violation 13</strong>: freertos_event_group.hpp:150:0
<em>Style</em>: The function 'clear_bits' is never used.</p>
<pre><code class="language-cpp">     147:    * @param bits_to_clear bits to clear
     148:    * @return EventBits_t bits cleared
     149:    */
&gt;&gt;&gt;  150:   EventBits_t clear_bits(const EventBits_t bits_to_clear) {
     151:     return xEventGroupClearBits(m_event_group, bits_to_clear);
     152:   }
     153:   /**
</code></pre></div>
<p><strong>Violation 14</strong>: freertos_event_group.hpp:198:0
<em>Style</em>: The function 'get_bits' is never used.</p>
<pre><code class="language-cpp">     195:    *
     196:    * @return EventBits_t Current value of the event group bits
     197:    */
&gt;&gt;&gt;  198:   EventBits_t get_bits(void) const { return xEventGroupGetBits(m_event_group); }
     199:   /**
     200:    * @brief Method to get the bits of the event group from an ISR.
     201:    * @ref https://www.freertos.org/xEventGroupGetBitsFromISR.html
</code></pre></div>
<p><strong>Violation 15</strong>: freertos_event_group.hpp:205:0
<em>Style</em>: The function 'get_bits_isr' is never used.</p>
<pre><code class="language-cpp">     202:    *
     203:    * @return EventBits_t Current value of the event group bits
     204:    */
&gt;&gt;&gt;  205:   EventBits_t get_bits_isr(void) const {
     206:     return xEventGroupGetBitsFromISR(m_event_group);
     207:   }
     208:   /**
</code></pre></div>
<p><strong>Violation 16</strong>: freertos_message_buffer.hpp:193:0
<em>Style</em>: The function 'available' is never used.</p>
<pre><code class="language-cpp">     190:    *
     191:    * @return size_t the number of bytes available in the buffer
     192:    */
&gt;&gt;&gt;  193:   size_t available(void) const {
     194:     return xMessageBufferSpaceAvailable(m_message_buffer);
     195:   }
     196:   /**
</code></pre></div>
<p><strong>Violation 17</strong>: freertos_message_buffer.hpp:209:0
<em>Style</em>: The function 'empty' is never used.</p>
<pre><code class="language-cpp">     206:    *
     207:    * @return BaseType_t pdTRUE if the message buffer is empty, pdFALSE otherwise
     208:    */
&gt;&gt;&gt;  209:   BaseType_t empty(void) { return xMessageBufferIsEmpty(m_message_buffer); }
     210:   /**
     211:    * @brief Method checking if the message buffer is full.
     212:    * @ref https://www.freertos.org/xMessageBufferIsFull.html
</code></pre></div>
<p><strong>Violation 18</strong>: freertos_message_buffer.hpp:216:0
<em>Style</em>: The function 'full' is never used.</p>
<pre><code class="language-cpp">     213:    *
     214:    * @return BaseType_t pdTRUE if the message buffer is full, pdFALSE otherwise
     215:    */
&gt;&gt;&gt;  216:   BaseType_t full(void) { return xMessageBufferIsFull(m_message_buffer); }
     217: };
     218: 
     219: #if configSUPPORT_STATIC_ALLOCATION
</code></pre></div>
<p><strong>Violation 19</strong>: freertos_queue.hpp:316:0
<em>Style</em>: The function 'send_back_isr' is never used.</p>
<pre><code class="language-cpp">     313:    * @return BaseType_t pdPASS if the item
     314:    * was successfully posted, otherwise errQUEUE_FULL.
     315:    */
&gt;&gt;&gt;  316:   BaseType_t send_back_isr(const T &amp;item,
     317:                            BaseType_t &amp;higher_priority_task_woken) {
     318:     return xQueueSendToBackFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     319:   }
</code></pre></div>
<p><strong>Violation 20</strong>: freertos_queue.hpp:372:0
<em>Style</em>: The function 'send_front_isr' is never used.</p>
<pre><code class="language-cpp">     369:    * @return BaseType_t pdPASS if the item
     370:    * was successfully posted, otherwise errQUEUE_FULL.
     371:    */
&gt;&gt;&gt;  372:   BaseType_t send_front_isr(const T &amp;item,
     373:                             BaseType_t &amp;higher_priority_task_woken) {
     374:     return xQueueSendToFrontFromISR(m_queue, &amp;item,
     375:                                     &amp;higher_priority_task_woken);
</code></pre></div>
<p><strong>Violation 21</strong>: freertos_queue.hpp:497:0
<em>Style</em>: The function 'messages_waiting' is never used.</p>
<pre><code class="language-cpp">     494:    *
     495:    * @return UBaseType_t The number of items stored in the queue.
     496:    */
&gt;&gt;&gt;  497:   UBaseType_t messages_waiting(void) { return uxQueueMessagesWaiting(m_queue); }
     498:   /**
     499:    * @brief Return the number of items stored in the queue from an ISR.
     500:    * @ref https://www.freertos.org/a00018.html#uxQueueMessagesWaitingFromISR
</code></pre></div>
<p><strong>Violation 22</strong>: freertos_queue.hpp:504:0
<em>Style</em>: The function 'messages_waiting_isr' is never used.</p>
<pre><code class="language-cpp">     501:    *
     502:    * @return UBaseType_t The number of items stored in the queue.
     503:    */
&gt;&gt;&gt;  504:   UBaseType_t messages_waiting_isr(void) {
     505:     return uxQueueMessagesWaitingFromISR(m_queue);
     506:   }
     507:   /**
</code></pre></div>
<p><strong>Violation 23</strong>: freertos_queue.hpp:513:0
<em>Style</em>: The function 'spaces_available' is never used.</p>
<pre><code class="language-cpp">     510:    *
     511:    * @return UBaseType_t The number of spaces available in the queue.
     512:    */
&gt;&gt;&gt;  513:   UBaseType_t spaces_available(void) { return uxQueueSpacesAvailable(m_queue); }
     514:   /**
     515:    * @brief Resets the queue to the empty state.
     516:    * @ref https://www.freertos.org/a00018.html#xQueueReset
</code></pre></div>
<p><strong>Violation 24</strong>: freertos_queue.hpp:529:0
<em>Style</em>: The function 'overwrite' is never used.</p>
<pre><code class="language-cpp">     526:    * @param item An item to be posted on the queue.
     527:    * @return BaseType_t pdPASS returned always.
     528:    */
&gt;&gt;&gt;  529:   BaseType_t overwrite(const T &amp;item) {
     530:     return xQueueOverwrite(m_queue, &amp;item);
     531:   }
     532:   /**
</code></pre></div>
<p><strong>Violation 25</strong>: freertos_queue.hpp:542:0
<em>Style</em>: The function 'overwrite_isr' is never used.</p>
<pre><code class="language-cpp">     539:    * unblocked a task of higher priority.
     540:    * @return BaseType_t pdPASS returned always.
     541:    */
&gt;&gt;&gt;  542:   BaseType_t overwrite_isr(const T &amp;item,
     543:                            BaseType_t &amp;higher_priority_task_woken) {
     544:     return xQueueOverwriteFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     545:   }
</code></pre></div>
<p><strong>Violation 26</strong>: freertos_queue.hpp:598:0
<em>Style</em>: The function 'peek_isr' is never used.</p>
<pre><code class="language-cpp">     595:    * @return BaseType_t pdPASS if the item
     596:    * was successfully peeked, otherwise pdFALSE.
     597:    */
&gt;&gt;&gt;  598:   BaseType_t peek_isr(T &amp;item, BaseType_t &amp;higher_priority_task_woken) {
     599:     return xQueuePeekFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     600:   }
     601:   /**
</code></pre></div>
<p><strong>Violation 27</strong>: freertos_queue.hpp:675:0
<em>Style</em>: The function 'full_isr' is never used.</p>
<pre><code class="language-cpp">     672:    *
     673:    * @return BaseType_t pdTRUE if the queue is full, pdFALSE otherwise.
     674:    */
&gt;&gt;&gt;  675:   BaseType_t full_isr(void) const { return xQueueIsQueueFullFromISR(m_queue); }
     676:   /**
     677:    * @brief Method checking if the queue is empty from an ISR.
     678:    * @ref https://www.freertos.org/a00018.html#xQueueIsQueueEmptyFromISR
</code></pre></div>
<p><strong>Violation 28</strong>: freertos_queue.hpp:682:0
<em>Style</em>: The function 'empty_isr' is never used.</p>
<pre><code class="language-cpp">     679:    *
     680:    * @return BaseType_t pdTRUE if the queue is empty, pdFALSE otherwise.
     681:    */
&gt;&gt;&gt;  682:   BaseType_t empty_isr(void) const {
     683:     return xQueueIsQueueEmptyFromISR(m_queue);
     684:   }
     685: };
</code></pre></div>
<p><strong>Violation 29</strong>: freertos_semaphore.hpp:211:0
<em>Style</em>: The function 'give_isr' is never used.</p>
<pre><code class="language-cpp">     208:    * @return BaseType_t pdTRUE if the semaphore was successfully given,
     209:    *
     210:    */
&gt;&gt;&gt;  211:   BaseType_t give_isr(BaseType_t &amp;high_priority_task_woken) {
     212:     return xSemaphoreGiveFromISR(m_semaphore, &amp;high_priority_task_woken);
     213:   }
     214:   /**
</code></pre></div>
<p><strong>Violation 30</strong>: freertos_semaphore.hpp:248:0
<em>Style</em>: The function 'take_isr' is never used.</p>
<pre><code class="language-cpp">     245:    * otherwise pdFALSE.
     246:    *
     247:    */
&gt;&gt;&gt;  248:   BaseType_t take_isr(BaseType_t &amp;high_priority_task_woken) {
     249:     return xSemaphoreTakeFromISR(m_semaphore, &amp;high_priority_task_woken);
     250:   }
     251:   /**
</code></pre></div>
<p><strong>Violation 31</strong>: freertos_semaphore.hpp:768:0
<em>Style</em>: The function 'recursions_count' is never used.</p>
<pre><code class="language-cpp">     765:    *
     766:    * @return uint8_t number of recursions of the recursive mutex.
     767:    */
&gt;&gt;&gt;  768:   uint8_t recursions_count(void) const { return m_recursions_count; }
     769: };
     770: 
     771: /**
</code></pre></div>
<p><strong>Violation 32</strong>: freertos_semaphore.hpp:891:0
<em>Style</em>: The function 'high_priority_task_woken' is never used.</p>
<pre><code class="language-cpp">     888:    * @return BaseType_t pdTRUE if the high priority task was woken, otherwise
     889:    * pdFALSE.
     890:    */
&gt;&gt;&gt;  891:   BaseType_t high_priority_task_woken(void) const {
     892:     return m_high_priority_task_woken;
     893:   }
     894:   /**
</code></pre></div>
<p><strong>Violation 33</strong>: freertos_stream_buffer.hpp:346:0
<em>Style</em>: The function 'free' is never used.</p>
<pre><code class="language-cpp">     343:    *
     344:    * @return size_t Number of bytes free in the stream buffer.
     345:    */
&gt;&gt;&gt;  346:   size_t free(void) { return xStreamBufferSpacesAvailable(m_stream_buffer); }
     347:   /**
     348:    * @brief Reset the stream buffer to the cleared state.
     349:    * @ref https://www.freertos.org/xStreamBufferReset.html
</code></pre></div>
<p><strong>Violation 34</strong>: freertos_stream_buffer.hpp:362:0
<em>Style</em>: The function 'set_trigger_level' is never used.</p>
<pre><code class="language-cpp">     359:    * buffer before a task that is blocked on a read operation will be unblocked.
     360:    * @return BaseType_t pdPass if the trigger level was set, pdFAIL otherwise.
     361:    */
&gt;&gt;&gt;  362:   BaseType_t set_trigger_level(size_t trigger_level_bytes) {
     363:     return xStreamBufferSetTriggerLevel(m_stream_buffer, trigger_level_bytes);
     364:   }
     365:   /**
</code></pre></div>
<p><strong>Violation 35</strong>: freertos_sw_timer.hpp:535:0
<em>Style</em>: The function 'reload_mode' is never used.</p>
<pre><code class="language-cpp">     532:    * @param auto_reload pdTRUE to enable auto-reload mode, pdFALSE to disable
     533:    * @return timer&amp; reference to the timer object
     534:    */
&gt;&gt;&gt;  535:   timer &amp;reload_mode(UBaseType_t auto_reload) {
     536:     if (m_timer) {
     537:       vTimerSetReloadMode(m_timer, auto_reload);
     538:     }
</code></pre></div>
<p><strong>Violation 36</strong>: freertos_sw_timer.hpp:567:0
<em>Style</em>: The function 'remaining_time' is never used.</p>
<pre><code class="language-cpp">     564:    * @return std::chrono::milliseconds remaining time before the timer expires
     565:    * in milliseconds.
     566:    */
&gt;&gt;&gt;  567:   std::chrono::milliseconds remaining_time(void) const {
     568:     return std::chrono::milliseconds{remaining_ticks()};
     569:   }
     570:   /**
</code></pre></div>
<p><strong>Violation 37</strong>: freertos_sw_timer.hpp:576:0
<em>Style</em>: The function 'running' is never used.</p>
<pre><code class="language-cpp">     573:    *
     574:    * @return BaseType_t pdTRUE if the timer is running, pdFALSE otherwise
     575:    */
&gt;&gt;&gt;  576:   BaseType_t running(void) const {
     577:     if (!m_timer) {
     578:       return pdFALSE;
     579:     }
</code></pre></div>
<p><strong>Violation 38</strong>: freertos_task.hpp:1041:0
<em>Style</em>: The function 'sleep_for' is never used.</p>
<pre><code class="language-cpp">    1038:  * @param duration duration to sleep
    1039:  */
    1040: template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt; 1041: void sleep_for(std::chrono::duration&lt;Rep, Period&gt; duration) {
    1042:   delay(duration);
    1043: }
    1044: 
</code></pre></div>
<p><strong>Violation 39</strong>: freertos_task.hpp:1108:0
<em>Style</em>: The function 'total_run_time' is never used.</p>
<pre><code class="language-cpp">    1105:    * @return UBaseType_t number of tasks
    1106:    */
    1107:   UBaseType_t count(void) const { return m_task_count; }
&gt;&gt;&gt; 1108:   std::chrono::milliseconds total_run_time(void) const {
    1109:     return std::chrono::milliseconds{m_total_run_time};
    1110:   }
    1111:   /**
</code></pre></div>
<p><strong>Violation 40</strong>: freertos_task.hpp:1116:0
<em>Style</em>: The function 'begin' is never used.</p>
<pre><code class="language-cpp">    1113:    *
    1114:    * @return const TaskStatus_t* begin iterator
    1115:    */
&gt;&gt;&gt; 1116:   const TaskStatus_t *begin(void) const { return m_status_array.data(); }
    1117:   /**
    1118:    * @brief Return the end iterator of the task status array.
    1119:    *
</code></pre></div>
<p><strong>Violation 41</strong>: freertos_task.hpp:1122:0
<em>Style</em>: The function 'end' is never used.</p>
<pre><code class="language-cpp">    1119:    *
    1120:    * @return const TaskStatus_t* end iterator
    1121:    */
&gt;&gt;&gt; 1122:   const TaskStatus_t *end(void) const {
    1123:     return m_status_array.data() + m_task_count;
    1124:   }
    1125: };
</code></pre></div>
<p><strong>Violation 42</strong>: freertos_message_buffer.hpp:193:0
<em>Style</em>: The function 'available' is never used.</p>
<pre><code class="language-cpp">     190:    *
     191:    * @return size_t the number of bytes available in the buffer
     192:    */
&gt;&gt;&gt;  193:   size_t available(void) const {
     194:     return xMessageBufferSpaceAvailable(m_message_buffer);
     195:   }
     196:   /**
</code></pre></div>
<p><strong>Violation 43</strong>: freertos_message_buffer.hpp:202:0
<em>Style</em>: The function 'reset' is never used.</p>
<pre><code class="language-cpp">     199:    *
     200:    * @return BaseType_t pdPass if the message buffer was reset, pdFAIL otherwise
     201:    */
&gt;&gt;&gt;  202:   BaseType_t reset(void) { return xMessageBufferReset(m_message_buffer); }
     203:   /**
     204:    * @brief Method checking if the message buffer is empty.
     205:    * @ref https://www.freertos.org/xMessageBufferIsEmpty.html
</code></pre></div>
<p><strong>Violation 44</strong>: freertos_message_buffer.hpp:209:0
<em>Style</em>: The function 'empty' is never used.</p>
<pre><code class="language-cpp">     206:    *
     207:    * @return BaseType_t pdTRUE if the message buffer is empty, pdFALSE otherwise
     208:    */
&gt;&gt;&gt;  209:   BaseType_t empty(void) { return xMessageBufferIsEmpty(m_message_buffer); }
     210:   /**
     211:    * @brief Method checking if the message buffer is full.
     212:    * @ref https://www.freertos.org/xMessageBufferIsFull.html
</code></pre></div>
<p><strong>Violation 45</strong>: freertos_message_buffer.hpp:216:0
<em>Style</em>: The function 'full' is never used.</p>
<pre><code class="language-cpp">     213:    *
     214:    * @return BaseType_t pdTRUE if the message buffer is full, pdFALSE otherwise
     215:    */
&gt;&gt;&gt;  216:   BaseType_t full(void) { return xMessageBufferIsFull(m_message_buffer); }
     217: };
     218: 
     219: #if configSUPPORT_STATIC_ALLOCATION
</code></pre></div>
<p><strong>Violation 46</strong>: freertos_queue.hpp:261:0
<em>Style</em>: The function 'send_isr' is never used.</p>
<pre><code class="language-cpp">     258:    * @return BaseType_t pdPASS if the item was successfully posted, otherwise
     259:    * errQUEUE_FULL.
     260:    */
&gt;&gt;&gt;  261:   BaseType_t send_isr(const T &amp;item, BaseType_t &amp;higher_priority_task_woken) {
     262:     return xQueueSendFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     263:   }
     264:   /**
</code></pre></div>
<p><strong>Violation 47</strong>: freertos_queue.hpp:316:0
<em>Style</em>: The function 'send_back_isr' is never used.</p>
<pre><code class="language-cpp">     313:    * @return BaseType_t pdPASS if the item
     314:    * was successfully posted, otherwise errQUEUE_FULL.
     315:    */
&gt;&gt;&gt;  316:   BaseType_t send_back_isr(const T &amp;item,
     317:                            BaseType_t &amp;higher_priority_task_woken) {
     318:     return xQueueSendToBackFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     319:   }
</code></pre></div>
<p><strong>Violation 48</strong>: freertos_queue.hpp:372:0
<em>Style</em>: The function 'send_front_isr' is never used.</p>
<pre><code class="language-cpp">     369:    * @return BaseType_t pdPASS if the item
     370:    * was successfully posted, otherwise errQUEUE_FULL.
     371:    */
&gt;&gt;&gt;  372:   BaseType_t send_front_isr(const T &amp;item,
     373:                             BaseType_t &amp;higher_priority_task_woken) {
     374:     return xQueueSendToFrontFromISR(m_queue, &amp;item,
     375:                                     &amp;higher_priority_task_woken);
</code></pre></div>
<p><strong>Violation 49</strong>: freertos_queue.hpp:459:0
<em>Style</em>: The function 'receive_isr' is never used.</p>
<pre><code class="language-cpp">     456:    * @return BaseType_t pdPASS if the item was successfully received, otherwise
     457:    * pdFALSE.
     458:    */
&gt;&gt;&gt;  459:   BaseType_t receive_isr(T &amp;item, BaseType_t &amp;higher_priority_task_woken) {
     460:     return xQueueReceiveFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     461:   }
     462:   /**
</code></pre></div>
<p><strong>Violation 50</strong>: freertos_queue.hpp:497:0
<em>Style</em>: The function 'messages_waiting' is never used.</p>
<pre><code class="language-cpp">     494:    *
     495:    * @return UBaseType_t The number of items stored in the queue.
     496:    */
&gt;&gt;&gt;  497:   UBaseType_t messages_waiting(void) { return uxQueueMessagesWaiting(m_queue); }
     498:   /**
     499:    * @brief Return the number of items stored in the queue from an ISR.
     500:    * @ref https://www.freertos.org/a00018.html#uxQueueMessagesWaitingFromISR
</code></pre></div>
<p><strong>Violation 51</strong>: freertos_queue.hpp:504:0
<em>Style</em>: The function 'messages_waiting_isr' is never used.</p>
<pre><code class="language-cpp">     501:    *
     502:    * @return UBaseType_t The number of items stored in the queue.
     503:    */
&gt;&gt;&gt;  504:   UBaseType_t messages_waiting_isr(void) {
     505:     return uxQueueMessagesWaitingFromISR(m_queue);
     506:   }
     507:   /**
</code></pre></div>
<p><strong>Violation 52</strong>: freertos_queue.hpp:513:0
<em>Style</em>: The function 'spaces_available' is never used.</p>
<pre><code class="language-cpp">     510:    *
     511:    * @return UBaseType_t The number of spaces available in the queue.
     512:    */
&gt;&gt;&gt;  513:   UBaseType_t spaces_available(void) { return uxQueueSpacesAvailable(m_queue); }
     514:   /**
     515:    * @brief Resets the queue to the empty state.
     516:    * @ref https://www.freertos.org/a00018.html#xQueueReset
</code></pre></div>
<p><strong>Violation 53</strong>: freertos_queue.hpp:520:0
<em>Style</em>: The function 'reset' is never used.</p>
<pre><code class="language-cpp">     517:    *
     518:    * @return BaseType_t pdPASS if the queue was reset, pdFAIL otherwise.
     519:    */
&gt;&gt;&gt;  520:   BaseType_t reset(void) { return xQueueReset(m_queue); }
     521:   /**
     522:    * @brief A version of send_back method that overwrites the items in the queue
     523:    * if it is full.
</code></pre></div>
<p><strong>Violation 54</strong>: freertos_queue.hpp:529:0
<em>Style</em>: The function 'overwrite' is never used.</p>
<pre><code class="language-cpp">     526:    * @param item An item to be posted on the queue.
     527:    * @return BaseType_t pdPASS returned always.
     528:    */
&gt;&gt;&gt;  529:   BaseType_t overwrite(const T &amp;item) {
     530:     return xQueueOverwrite(m_queue, &amp;item);
     531:   }
     532:   /**
</code></pre></div>
<p><strong>Violation 55</strong>: freertos_queue.hpp:542:0
<em>Style</em>: The function 'overwrite_isr' is never used.</p>
<pre><code class="language-cpp">     539:    * unblocked a task of higher priority.
     540:    * @return BaseType_t pdPASS returned always.
     541:    */
&gt;&gt;&gt;  542:   BaseType_t overwrite_isr(const T &amp;item,
     543:                            BaseType_t &amp;higher_priority_task_woken) {
     544:     return xQueueOverwriteFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     545:   }
</code></pre></div>
<p><strong>Violation 56</strong>: freertos_queue.hpp:598:0
<em>Style</em>: The function 'peek_isr' is never used.</p>
<pre><code class="language-cpp">     595:    * @return BaseType_t pdPASS if the item
     596:    * was successfully peeked, otherwise pdFALSE.
     597:    */
&gt;&gt;&gt;  598:   BaseType_t peek_isr(T &amp;item, BaseType_t &amp;higher_priority_task_woken) {
     599:     return xQueuePeekFromISR(m_queue, &amp;item, &amp;higher_priority_task_woken);
     600:   }
     601:   /**
</code></pre></div>
<p><strong>Violation 57</strong>: freertos_queue.hpp:668:0
<em>Style</em>: The function 'name' is never used.</p>
<pre><code class="language-cpp">     665:    *
     666:    * @return const char* The name of the queue.
     667:    */
&gt;&gt;&gt;  668:   const char *name(void) const { return pcQueueGetName(m_queue); }
     669:   /**
     670:    * @brief Method checking if the queue is full from an ISR.
     671:    * @ref https://www.freertos.org/a00018.html#xQueueIsQueueFullFromISR
</code></pre></div>
<p><strong>Violation 58</strong>: freertos_queue.hpp:675:0
<em>Style</em>: The function 'full_isr' is never used.</p>
<pre><code class="language-cpp">     672:    *
     673:    * @return BaseType_t pdTRUE if the queue is full, pdFALSE otherwise.
     674:    */
&gt;&gt;&gt;  675:   BaseType_t full_isr(void) const { return xQueueIsQueueFullFromISR(m_queue); }
     676:   /**
     677:    * @brief Method checking if the queue is empty from an ISR.
     678:    * @ref https://www.freertos.org/a00018.html#xQueueIsQueueEmptyFromISR
</code></pre></div>
<p><strong>Violation 59</strong>: freertos_queue.hpp:682:0
<em>Style</em>: The function 'empty_isr' is never used.</p>
<pre><code class="language-cpp">     679:    *
     680:    * @return BaseType_t pdTRUE if the queue is empty, pdFALSE otherwise.
     681:    */
&gt;&gt;&gt;  682:   BaseType_t empty_isr(void) const {
     683:     return xQueueIsQueueEmptyFromISR(m_queue);
     684:   }
     685: };
</code></pre></div>
<p><strong>Violation 60</strong>: freertos_semaphore.hpp:211:0
<em>Style</em>: The function 'give_isr' is never used.</p>
<pre><code class="language-cpp">     208:    * @return BaseType_t pdTRUE if the semaphore was successfully given,
     209:    *
     210:    */
&gt;&gt;&gt;  211:   BaseType_t give_isr(BaseType_t &amp;high_priority_task_woken) {
     212:     return xSemaphoreGiveFromISR(m_semaphore, &amp;high_priority_task_woken);
     213:   }
     214:   /**
</code></pre></div>
<p><strong>Violation 61</strong>: freertos_semaphore.hpp:248:0
<em>Style</em>: The function 'take_isr' is never used.</p>
<pre><code class="language-cpp">     245:    * otherwise pdFALSE.
     246:    *
     247:    */
&gt;&gt;&gt;  248:   BaseType_t take_isr(BaseType_t &amp;high_priority_task_woken) {
     249:     return xSemaphoreTakeFromISR(m_semaphore, &amp;high_priority_task_woken);
     250:   }
     251:   /**
</code></pre></div>
<p><strong>Violation 62</strong>: freertos_semaphore.hpp:768:0
<em>Style</em>: The function 'recursions_count' is never used.</p>
<pre><code class="language-cpp">     765:    *
     766:    * @return uint8_t number of recursions of the recursive mutex.
     767:    */
&gt;&gt;&gt;  768:   uint8_t recursions_count(void) const { return m_recursions_count; }
     769: };
     770: 
     771: /**
</code></pre></div>
<p><strong>Violation 63</strong>: freertos_semaphore.hpp:891:0
<em>Style</em>: The function 'high_priority_task_woken' is never used.</p>
<pre><code class="language-cpp">     888:    * @return BaseType_t pdTRUE if the high priority task was woken, otherwise
     889:    * pdFALSE.
     890:    */
&gt;&gt;&gt;  891:   BaseType_t high_priority_task_woken(void) const {
     892:     return m_high_priority_task_woken;
     893:   }
     894:   /**
</code></pre></div>
<p><strong>Violation 64</strong>: freertos_task.hpp:1041:0
<em>Style</em>: The function 'sleep_for' is never used.</p>
<pre><code class="language-cpp">    1038:  * @param duration duration to sleep
    1039:  */
    1040: template &lt;typename Rep, typename Period&gt;
&gt;&gt;&gt; 1041: void sleep_for(std::chrono::duration&lt;Rep, Period&gt; duration) {
    1042:   delay(duration);
    1043: }
    1044: 
</code></pre></div>
<p><strong>Violation 65</strong>: freertos_task.hpp:1108:0
<em>Style</em>: The function 'total_run_time' is never used.</p>
<pre><code class="language-cpp">    1105:    * @return UBaseType_t number of tasks
    1106:    */
    1107:   UBaseType_t count(void) const { return m_task_count; }
&gt;&gt;&gt; 1108:   std::chrono::milliseconds total_run_time(void) const {
    1109:     return std::chrono::milliseconds{m_total_run_time};
    1110:   }
    1111:   /**
</code></pre></div>
<p><strong>Violation 66</strong>: freertos_task.hpp:1116:0
<em>Style</em>: The function 'begin' is never used.</p>
<pre><code class="language-cpp">    1113:    *
    1114:    * @return const TaskStatus_t* begin iterator
    1115:    */
&gt;&gt;&gt; 1116:   const TaskStatus_t *begin(void) const { return m_status_array.data(); }
    1117:   /**
    1118:    * @brief Return the end iterator of the task status array.
    1119:    *
</code></pre></div>
<p><strong>Violation 67</strong>: freertos_task.hpp:1122:0
<em>Style</em>: The function 'end' is never used.</p>
<pre><code class="language-cpp">    1119:    *
    1120:    * @return const TaskStatus_t* end iterator
    1121:    */
&gt;&gt;&gt; 1122:   const TaskStatus_t *end(void) const {
    1123:     return m_status_array.data() + m_task_count;
    1124:   }
    1125: };
</code></pre></div>
<p><strong>Violation 68</strong>: freertos_sw_timer.hpp:535:0
<em>Style</em>: The function 'reload_mode' is never used.</p>
<pre><code class="language-cpp">     532:    * @param auto_reload pdTRUE to enable auto-reload mode, pdFALSE to disable
     533:    * @return timer&amp; reference to the timer object
     534:    */
&gt;&gt;&gt;  535:   timer &amp;reload_mode(UBaseType_t auto_reload) {
     536:     if (m_timer) {
     537:       vTimerSetReloadMode(m_timer, auto_reload);
     538:     }
</code></pre></div>
<p><strong>Violation 69</strong>: freertos_sw_timer.hpp:567:0
<em>Style</em>: The function 'remaining_time' is never used.</p>
<pre><code class="language-cpp">     564:    * @return std::chrono::milliseconds remaining time before the timer expires
     565:    * in milliseconds.
     566:    */
&gt;&gt;&gt;  567:   std::chrono::milliseconds remaining_time(void) const {
     568:     return std::chrono::milliseconds{remaining_ticks()};
     569:   }
     570:   /**
</code></pre></div>
<p><strong>Violation 70</strong>: freertos_sw_timer.hpp:576:0
<em>Style</em>: The function 'running' is never used.</p>
<pre><code class="language-cpp">     573:    *
     574:    * @return BaseType_t pdTRUE if the timer is running, pdFALSE otherwise
     575:    */
&gt;&gt;&gt;  576:   BaseType_t running(void) const {
     577:     if (!m_timer) {
     578:       return pdFALSE;
     579:     }
</code></pre></div>
<p><strong>Violation 71</strong>: freertos_sw_timer.hpp:587:0
<em>Style</em>: The function 'name' is never used.</p>
<pre><code class="language-cpp">     584:    *
     585:    * @return const char* name of the timer
     586:    */
&gt;&gt;&gt;  587:   const char *name(void) const {
     588:     if (!m_timer) {
     589:       return nullptr;
     590:     }
</code></pre></div>
<p><strong>Violation 72</strong>: freertos_event_group.hpp:117:0
<em>Style</em>: The function 'handle' is never used.</p>
<pre><code class="language-cpp">     114:    *
     115:    * @return EventGroupHandle_t event group handle
     116:    */
&gt;&gt;&gt;  117:   EventGroupHandle_t handle(void) const { return m_event_group; }
     118: 
     119:   /**
     120:    * @brief Method to set bits in the event group.
</code></pre></div>
<p><strong>Violation 73</strong>: freertos_event_group.hpp:126:0
<em>Style</em>: The function 'set_bits' is never used.</p>
<pre><code class="language-cpp">     123:    * @param bits_to_set bits to set
     124:    * @return EventBits_t bits set
     125:    */
&gt;&gt;&gt;  126:   EventBits_t set_bits(const EventBits_t bits_to_set) {
     127:     return xEventGroupSetBits(m_event_group, bits_to_set);
     128:   }
     129:   /**
</code></pre></div>
<p><strong>Violation 74</strong>: freertos_event_group.hpp:136:0
<em>Style</em>: The function 'set_bits_isr' is never used.</p>
<pre><code class="language-cpp">     133:    * @param bits_to_set bits to set
     134:    * @return EventBits_t bits set
     135:    */
&gt;&gt;&gt;  136:   EventBits_t set_bits_isr(const EventBits_t bits_to_set) {
     137:     BaseType_t higher_priority_task_woken = pdFALSE;
     138:     const EventBits_t bits_set = xEventGroupSetBitsFromISR(
     139:         m_event_group, bits_to_set, &amp;higher_priority_task_woken);
</code></pre></div>
<p><strong>Violation 75</strong>: freertos_event_group.hpp:150:0
<em>Style</em>: The function 'clear_bits' is never used.</p>
<pre><code class="language-cpp">     147:    * @param bits_to_clear bits to clear
     148:    * @return EventBits_t bits cleared
     149:    */
&gt;&gt;&gt;  150:   EventBits_t clear_bits(const EventBits_t bits_to_clear) {
     151:     return xEventGroupClearBits(m_event_group, bits_to_clear);
     152:   }
     153:   /**
</code></pre></div>
<p><strong>Violation 76</strong>: freertos_event_group.hpp:198:0
<em>Style</em>: The function 'get_bits' is never used.</p>
<pre><code class="language-cpp">     195:    *
     196:    * @return EventBits_t Current value of the event group bits
     197:    */
&gt;&gt;&gt;  198:   EventBits_t get_bits(void) const { return xEventGroupGetBits(m_event_group); }
     199:   /**
     200:    * @brief Method to get the bits of the event group from an ISR.
     201:    * @ref https://www.freertos.org/xEventGroupGetBitsFromISR.html
</code></pre></div>
<p><strong>Violation 77</strong>: freertos_event_group.hpp:205:0
<em>Style</em>: The function 'get_bits_isr' is never used.</p>
<pre><code class="language-cpp">     202:    *
     203:    * @return EventBits_t Current value of the event group bits
     204:    */
&gt;&gt;&gt;  205:   EventBits_t get_bits_isr(void) const {
     206:     return xEventGroupGetBitsFromISR(m_event_group);
     207:   }
     208:   /**
</code></pre></div>
<p><strong>Violation 78</strong>: freertos_stream_buffer.hpp:337:0
<em>Style</em>: The function 'available' is never used.</p>
<pre><code class="language-cpp">     334:    *
     335:    * @return size_t Number of bytes available in the stream buffer.
     336:    */
&gt;&gt;&gt;  337:   size_t available(void) {
     338:     return xStreamBufferBytesAvailable(m_stream_buffer);
     339:   }
     340:   /**
</code></pre></div>
<p><strong>Violation 79</strong>: freertos_stream_buffer.hpp:346:0
<em>Style</em>: The function 'free' is never used.</p>
<pre><code class="language-cpp">     343:    *
     344:    * @return size_t Number of bytes free in the stream buffer.
     345:    */
&gt;&gt;&gt;  346:   size_t free(void) { return xStreamBufferSpacesAvailable(m_stream_buffer); }
     347:   /**
     348:    * @brief Reset the stream buffer to the cleared state.
     349:    * @ref https://www.freertos.org/xStreamBufferReset.html
</code></pre></div>
<p><strong>Violation 80</strong>: freertos_stream_buffer.hpp:353:0
<em>Style</em>: The function 'reset' is never used.</p>
<pre><code class="language-cpp">     350:    *
     351:    * @return BaseType_t pdPass if the stream buffer was reset, pdFAIL otherwise.
     352:    */
&gt;&gt;&gt;  353:   BaseType_t reset(void) { return xStreamBufferReset(m_stream_buffer); }
     354:   /**
     355:    * @brief Set the trigger level of the stream buffer.
     356:    * @ref https://www.freertos.org/xStreamBufferSetTriggerLevel.html
</code></pre></div>
<p><strong>Violation 81</strong>: freertos_stream_buffer.hpp:362:0
<em>Style</em>: The function 'set_trigger_level' is never used.</p>
<pre><code class="language-cpp">     359:    * buffer before a task that is blocked on a read operation will be unblocked.
     360:    * @return BaseType_t pdPass if the trigger level was set, pdFAIL otherwise.
     361:    */
&gt;&gt;&gt;  362:   BaseType_t set_trigger_level(size_t trigger_level_bytes) {
     363:     return xStreamBufferSetTriggerLevel(m_stream_buffer, trigger_level_bytes);
     364:   }
     365:   /**
</code></pre></div>
<p><strong>Violation 82</strong>: freertos_stream_buffer.hpp:370:0
<em>Style</em>: The function 'handle' is never used.</p>
<pre><code class="language-cpp">     367:    *
     368:    * @return StreamBufferHandle_t Handle of the stream buffer.
     369:    */
&gt;&gt;&gt;  370:   StreamBufferHandle_t handle(void) const { return m_stream_buffer; }
     371:   /**
     372:    * @brief Check if the stream buffer is empty.
     373:    * @ref https://www.freertos.org/xStreamBufferIsEmpty.html
</code></pre></div>
<p><strong>Violation 83</strong>: freertos_stream_buffer.hpp:377:0
<em>Style</em>: The function 'empty' is never used.</p>
<pre><code class="language-cpp">     374:    *
     375:    * @return BaseType_t pdTRUE if the stream buffer is empty, pdFALSE otherwise.
     376:    */
&gt;&gt;&gt;  377:   BaseType_t empty(void) { return xStreamBufferIsEmpty(m_stream_buffer); }
     378:   /**
     379:    * @brief Check if the stream buffer is full.
     380:    * @ref https://www.freertos.org/xStreamBufferIsFull.html
</code></pre></div>
<p><strong>Violation 84</strong>: freertos_stream_buffer.hpp:384:0
<em>Style</em>: The function 'full' is never used.</p>
<pre><code class="language-cpp">     381:    *
     382:    * @return BaseType_t pdTRUE if the stream buffer is full, pdFALSE otherwise.
     383:    */
&gt;&gt;&gt;  384:   BaseType_t full(void) { return xStreamBufferIsFull(m_stream_buffer); }
     385: };
     386: 
     387: #if configSUPPORT_STATIC_ALLOCATION
</code></pre></div>
<h3 id="analysis-errors_1">Analysis Errors</h3>
<p>Some files could not be fully analyzed:</p>
<div class="code-block"><pre><code>/home/runner/work/freertos_cpp_wrappers/freertos_cpp_wrappers/src/freertos_task.cc:0:0: error: Bailing out from analysis: Checking file failed: Failed to execute addon 'misra' - exitcode is 1 [internalError]
/home/runner/work/freertos_cpp_wrappers/freertos_cpp_wrappers/include/freertos.hpp:0:0: error: Bailing out from analysis: Checking file failed: Failed to execute addon 'misra' - exitcode is 1 [internalError]
/home/runner/work/freertos_cpp_wrappers/freertos_cpp_wrappers/include/freertos_task.hpp:0:0: error: Bailing out from analysis: Checking file failed: Failed to execute addon 'misra' - exitcode is 1 [internalError]
</code></pre></div>
<h3 id="analysis-notes_1">Analysis Notes</h3>
<ul>
<li><strong>Tool</strong>: cppcheck with all rules enabled (--enable=all)</li>
<li><strong>Checks</strong>: All available cppcheck checks including MISRA C 2012, style, performance, portability, security</li>
<li><strong>Scope</strong>: Library modules only (src/, include/)</li>
<li><strong>Integration</strong>: This analysis complements the existing clang-tidy static analysis</li>
<li><strong>MISRA Compliance</strong>: MISRA rule texts cannot be displayed due to licensing restrictions</li>
</ul>
</div><div class="section"><h2 id="detailed-clang-tidy-analysis">Detailed clang-tidy Analysis</h2>
<h3 id="actionable-issues-with-code-context-2-issues">Actionable Issues with Code Context (2 issues)</h3>
<h4 id="cert-secure-coding-2-issues">CERT Secure Coding (2 issue(s))</h4>
<h5 id="cert-dcl21-cpp-2-issues">cert-dcl21-cpp (2 issue(s))</h5>
<p><strong>Issue 1</strong>: freertos_semaphore.hpp:424:3
<em>Reason: Const Correctness</em></p>
<p><strong>Message</strong>: overloaded 'operator++' returns a reference instead of a constant object type</p>
<pre><code class="language-cpp">     421:    */
     422:   // NOLINTNEXTLINE(cert-dcl21-cpp): RAII class, copy is deleted -
     423:   // post-increment returns reference instead of copy
&gt;&gt;&gt;  424:   counting_semaphore &amp;operator++(int) {
     425:     give();
     426:     return *this;
     427:   }
</code></pre></div>
<p><strong>Issue 2</strong>: freertos_semaphore.hpp:436:3
<em>Reason: Const Correctness</em></p>
<p><strong>Message</strong>: overloaded 'operator--' returns a reference instead of a constant object type</p>
<pre><code class="language-cpp">     433:    */
     434:   // NOLINTNEXTLINE(cert-dcl21-cpp): RAII class, copy is deleted -
     435:   // post-decrement returns reference instead of copy
&gt;&gt;&gt;  436:   counting_semaphore &amp;operator--(int) {
     437:     take();
     438:     return *this;
     439:   }
</code></pre></div>
<p><em>Generated: July 25, 2025</em>
<em>Tools: clang-tidy + Enhanced cppcheck (all rules) + MISRA C++ (cppcheck)</em>
<em>Scope: Library modules only</em></p></div>
        
        <div class="timestamp">
            Generated on July 25, 2025 at 11:02 AM by FreeRTOS C++ Wrappers build system
        </div>
    </div>
</body>
</html>